# Clean Architecture
Clean Architecture: A Craftsman's Guide to Software Structure and Design

### DirectCloudLAB Study Group
사내 스터디 그룹 (매월 둘째주 넷째주 목요일)

## Table of Contents

|  Chapter  |      Title       |  Page   |    Date    |
|:---------:|:----------------:|:-------:|:----------:|
| [00](#0)  |   Introduction   |     000-004      | 04.01.2023 |
| [01](#1)  |    설계와 아키텍처란?    | 005-014 | 04.01.2023 |
| [02](#2)  | 두 가지 가치에 대한 이야기  | 015-022 | 04.02.2023 |
| [03](#3)  |     패러다임 개요      | 023-028 | 04.02.2023 |
| [04](#4)  |    구조적 프로그래밍     | 029-036 | 04.02.2023 |
| [05](#5)  |   객체 지향 프로그래밍    | 037-050 | 04.03.2023 |
| [06](#6)  |    함수형 프로그래밍     | 053-060 | 04.03.2023 |
| [07](#7)  |  SRP: 단일 책임 원칙   | 061-072 | 04.04.2023 |
| [08](#8)  |  OCP: 개방-폐쇄 원칙   | 073-080 | 04.06.2023 |
| [09](#9)  | LSP: 리스코프 치환 원칙  | 081-086 | 04.06.2023 |
| [10](#10) | ISP: 인터페이스 분리 원칙 | 087-090 | 04.06.2023 |
| [11](#11) | DIP: 의존성 역전 원칙 | 091-096 | 04.07.2023 |
|    12     |       컴포넌트       | 097-106 | 04.07.2023 |
|    13     |     컴포넌트 응집도     | 107-114 | 04.08.2023 |
|    14     |     컴포넌트 결합      | 115-138 | 04.08.2023 |
|    15     |      아키텍처란?      | 139-154 | 04.09.2023 |
|    16     |       독립성        | 155-168 ||
|    17     |     경계: 선 긋기     | 169-184 ||
|    18     |      경계 해부학      | 185-192 ||
|    19     |      정책과 수준      | 193-198 ||
|    20     |      업무 규칙       | 199-206 ||
|    21     |    소리치는 아키텍처     | 207-212 ||
|    22     |     클린 아키텍처      | 213-222 ||
|    23     |   프레젠터와 험블 객체    | 223-228 ||
|    24     |      부분적 경계      | 229-234 ||
|    25     |      계층과 경계      | 235-244 ||
|    26     |  메인(Main) 컴포넌트   | 245-250 ||
|    27     |  '크고 작은 모든'서비스들  | 251-260 ||
|    28     |      테스트 경계      | 261-266 ||
|    29     |   클린 임베디드 아키텍처   | 267-286 ||
|    30     |  데이터베이스는 세부사항이다  | 287-296 ||
|    31     |    웹은 세부사항이다     | 297-302 ||
|    32     |  프레밍워크는 세부사항이다   | 303-308 ||
|    33     |  사례 연구: 비디오 판매   | 309-314 ||
|    34     |     빠져 있는 장      | 315-333 ||
----
# 0
## Introduction
> 옮긴이의 글, 추천사, 서문, 감사의 글

<details><summary>Dead Code</summary>

> 실행되지 않는 코드 
> 
> Dead code refers to sections of a computer program that are no longer executed or accessed by other parts of the program.

#### Dead Code
- 프로그램의 크기 ↑
- 유지보수성 ↓
- 가독성 ↓

#### Types of dead code
- **주석 처리된 코드** 
  - 주석처리 된 코드로, 더 이상 사용되지 않거나 삭제되지 않아 불필요 하게 남아 있는 코드.
- **호출되지 않는 함수/메서드** 
  - 사용처 없이 방치되어 있는 함수/메서드.
- **조건문에서 실행되지 않는 코드** 
  - 조건문(`if/switch`)에서 조건이 항상 `false` 가 되어 실행되지 않는 코드.
- **접근 불가한 코드** 
  - 분기 명령문(`return, break`) 뒤에 위치해 있지만 앞선 잘못된 로직으로 인해 절대 실행될 수 없는 코드.
- **중복 코드** 
  - 여러번 반복하여 존재하는 동일한 코드.
- **폐기된 코드** 
  - 더 이상 사용되지 않는 코드.

#### Dead code in the real world  
Dead code 로 인해 문제가 발생한 실 사례는 MS사의 Windows98 OS가 있음.
- Windows98 은 기존의 Windows95와 유사한 구조를 지님.
- 수많은 코드가 재사용 됨.
  - 가져온 코드 중에서 사용되지 않는 불필요한 코드(`폐기된 코드`)가 존재. 
  - 하지만 이는 방치된 채로 남아 있었음.
- 불필요한 코드는 메모리와 디스크 공간 낭비를 초래.
  - 느려진 속도, 안정성 문제 발생.
    - 느려진 속도: 부팅, 응용 프로그램 etc.
    - 안정성: OS 충돌, 오동작 etc.
- 새 OS Windows ME 를 통해 문제 해결.
  - Refactoring 을 통한 Dead Code 제거. 

</details>

<details><summary>Speculative generality</summary>

> 추측성 일반화

추후에 사용할 것이 예상하여 불필요하게 확장성(`overy extensible`) 있게 만들어 둔 코드.
- 실제로 사용되지 않을 수 있음.
  - 초기에 사용 가능성을 염두에 두고 만들어 두었지만 사용되지 않음. 
- 유지 보수를 어렵게 만듬.

Unused configuration options, over-engineered abstractions, unused code paths, and unnecessary extensibility.

</details>

<details><summary>Accidental complexity</summary>

> 부수적인 복잡성

부수적인 복잡성은 '맨먼스 미신(The Mythical Man-Month)' 서적에서 등장하는 단어.

`"어떤 것이 복잡하다고 느껴지는 이유는 그것이 복잡하기 때문이 아니라, 우리가 그것을 이해하지 못하기 때문이다. 따라서 복잡성을 제거하는 방법은 어떻게든 이해할 수 있도록 만드는 것이다. 이해할 수 없는 것을 단순화하면, 부수적인 복잡성(accidental complexity)이 줄어든다.`

즉, 복잡성의 원인은 사람들이 어떤 것을 이해하기 어렵기 때문.
- 이를 해결하기 위해 → 복잡성 줄이기

#### 복잡도의 이유
- **적절하게 추상화 되지 않음**
- **충분한 문서화의 부재**
  - 부족한 설명과 충분하지 못한 설명으로 인해 복잡성 증가. 
- **복잡한 시스템 구조**
  - 전체적인 시스템 구조 파악이 어려워지면 이해하기 어려운 코드가 작성됨. 
- **불분명한 요구사항**
  - 요구사항이 명확치 않아 개발자들이 이해가 부족한 채로 작성한 코드는 복잡함을 초래. 
- **Legacy Code**
  - 주기적인 refactoring 또는 새 코드 작성이 야기됨.

</details>

<details><summary>구현과 측정</summary>

`"아키텍처는 구현과 측정을 통해 증명해야 하는 가설이다."`

*소프트웨어 아키텍처*는 시스템의 전반적인 설계와 구조를 결정하므로 시스템의 성능, 안정성, 확장성 등을 결정짓는 매우 중요한 역할을 한다.

#### 잘못 설계된 아키텍처
잘못 설계된 아키텍처는 시스템의 문제점과 결함을 발생시킨다.
- 시스템 성능 ↓  
- 유지보수의 어려움 ↑ 
- 개발비용 ↑

#### 구현과 측정
아키텍처가 올바르게 설계되었는지 알기 위해서는 구현과 측정을 해야 함.
- 시스템의 요구사항을 충족시키는지?
- 성능과 안정성이 적절한지?

**구현(Implementation):**
- 아키텍처 설계를 바탕으로, 소프트웨어 시스템의 실제 코드를 작성하는 과정. 
- 설계의 유효성과 적절성을 확인 가능. 

**측정(Measurement):** 
- 아키텍처 설계의 유효성을 검증하는 과정입니다. 
- 성능, 안정성, 확장성 등을 측정.
- 측정법:
  - 성능 측정:
    - 처리 속도, 응답 시간, 처리량 etc.
      - 측정 도구 예) `Apache Bench`, `JMeter` 
  - 코드 품질 검사
  - 테스트:
    - 기능 검증
    - type of tests: unit, integration, system, acceptance, regression, performance, and security.
    - 테스트 도구 예) `pytest`, `JUnit`, `Selenium`
  - 로그 분석
    - 시스템 동작을 이해
    - 문제 파악
    - 로그 분석 도구 예) `Datadog`, `Splunk`, `ELK Stack`, `Graylog`, `Loggly`.
  - 코드 복잡도 분석
    - 복잡도 분석 도구 예) `CodeClimate`, `SonarQube`

</details>

다양한 시스템이 비슷한 아키텍처 규칙을 공유하는 이유 → 소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적
- `다른 모든 변수에 독립적`: 아키텍처 규칙은 시스템을 구성하는 기술, 인력, 일정, 예산 등과는 관계없이 동일하게 적용될 수 있다는 것.

소프트웨어 아키텍처 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다.

----
# 1
## 설계와 아키텍처란?

<details><summary>설계와 아키텍처</summary>

> 둘 사이에는 아무런 차이가 없다.

설계(design):
- 저수준의 구조, 결정사항 등.

아키텍처(architecture):
- 저수준의 세부사항과 고수준의 무언가를 가리킬 때 흔히 사용.
  - 저수준(low-level): 
    - 메서드의 구현, 데이터 베이스 스키마 etc.
    - 구체적이고 구현적인 세부 사항.
  - 고수준(high-level):
    - 아키텍처, 구조, 비즈니스 로직 etc.
    - 저수준의 구성요소들을 조합하여 만들어지는 추상화된 개념.

저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성 요소.

</details>

<details><summary>좋은 설계</summary>

> 비용은 최소화, 생산성은 최대화.

좋은 설계는 비용을 절감시켜 준다. 
- 기능 만들기 또는 유지보수하는 데 투입되는 인력이 최소화 됨.
- 고객의 요구사항을 탑재한 기능을 만들어 내는 비용이 절감됨.

좋은 설계는 단순 명료함.

`빨리 가는 유일한 방법은 제대로 가는 것.`
- TDD 를 적용한 날이 그렇지 않은 날 보다 되려 작업속도가 향상.
- 속도만을 생각하여 빠르게 작성한 지저분한 코드는 생산성을 갈수록 저하 시킴.
  - 이전에 작성한 코드를 정리하는 일은 거의 발생 X
    - 다음 업무를 진행해야 하기에... 

</details>

----
# 2
## 두가지 가치에 대한 이야기 
모든 소프트웨어 시스템은 두 가지 가치를 제공한다, 행위와 구조. 이 두가지를 함께 잘 유지시켜야 한다.
- 어느 하나도 배제되어서는 안됨.

<details><summary>행위</summary>

> Behavior

**행위**: 시스템이 수행하는 작업이나 기능을 의미.

- 시스템이 어떤 input 을 받아서 그에 따라 어떤 output 을 생성하는지
- 그 과정에서 어떤 상호작용을 하는지를 나타낸다.

`아키텍처에서 행위는 구성 요소들 간의 상호작용과 함께 고려된다.`
- 구성요소(Component): 시스템을 구성하는 개별적인 module or block.
  - 구성요소는 실현 가능한 코드로 구현된다. 

</details>

<details><summary>구조</summary>

> Structure

구조는 변경하기 쉬워야 한다. Software 라는 단어가 내포한 의미처럼.

변경하기 쉬운 구조를 위해서는 Architecture 의 형태가 독립적이어야 한다.
- `아키텍처가 특정 현태를 다른 형태보다 선호하면하수록, 새로운 기능을 이 구조에 맞추는게 더 힘들어진다.`

수정의 용이성은 비용과 직접적인 연관성을 갖는다.
- **수정이 용이 O:** 비용 ↓  
- **수정이 용이 X:** 비용 ↑ 
  - 수정이 현실적으로 불가능한 시스템: 변경에 드는 비용 > 변경으로 인해 창출되는 수익 

</details>

----
# 3
## 패러다임 개요

<details><summary>A-O</summary>

> 최초의 컴파일러

그레이스 호퍼(Grace Hoper)가 발명
-  **A-O:** 1952년 그레이스 호퍼와 연구팀이 개발한 최초의 컴파일러
  - 사실상 A-O 컴파일러 자체는 Billous 와 Conrad 가 개발.
    - John McCarthy Billous: 
      - 미국의 컴퓨터 과학자
    - Corrado Bohm Conrad:
      - 이탈리아의 컴퓨터 과학자

`Compiler` 라는 용어 자체도 그레이스 호퍼가 처음으로 사용.

</details>

<details><summary>프로그래밍 패러다임</summary>

> Programming paradigm

- **programming paradigm**: 
  - 컴퓨터 프로그램을 설계하고 구현하는 방법론이나 철학을 의미.
  - 프로그래밍을 하는 방법
  - 언어와는 독립적

</details> 

<details><summary>3 Types of programming paradigm</summary>

1. **구조적 프로그래밍**(structural programming):
    - 에츠허르 비버 데이크스트라(Edsger Wybe Dijkstra)가 발견
    - 무분별한 goto 는 해롭다.
      - 이를 제어문(`if/then/else`, `do/while/until`)으로 대체
      - 관련 논문: [`Go To Statement Considered Harmful` (GOTO 문의 해로움)](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html)
        - 관련된 문구: `"The go to statement as it stands is just too primitive; it is too much an invitation to make a mess of one's program."`
      - Goto 문
        - 코드의 제어 흐름을 제어하는 명령문.
        - 프로그래머가 원하는 위치로 코드를 점프시켜 실행하도록 도와줌.
        - 이는 가독성, 유지보수성, 디버깅을 어렵게 만듬.   
          프로그래밍의 실행 흐름이 복잡해지고 예측하기 어려워지기 때문. 또한, 로직이 불명확하게 됨.

`구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.`

2. **객체지향 프로그래밍**(object-oriented programming):
    - Ole-Johan Dahal 과 Kristen Nygarard 가 발견.
    - 함수 호출 스택 프레임(stack frame)을 힙(heap)으로 옮기는 것에 대한 아이디어
      - `함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음`
      - 기존: 함수 호출 스택 프레임은 함수 호출 시, 스택 메모리에 쌓임 → 함수 호출 후 스택에서 제거됨. → 지역 변수 사라짐. 
      - 변화: 함수 호출 스택 프레임을 힙 메모리에 할당 → 함수 호출후에도 지역 변수가 남아있음. (오랫동안 유지)
    - 이를 통해 객체(object)와 클래스(class)를 만들어 냄.(객체 프로그래밍에서 중요한 개념)
      - 상속, 캡슐화, 다형성 
    - 데이터와 함수를 하나의 개념으로 묶어 객체를 생성하여 프로그램을 구성하는 방식을 제안 

`객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.`

3. **함수형 프로그래밍**(functional programming):
    - 함수형 프로그래밍 패러다임은 람다 계산법(Lambda Calculus)을 기반으로 한다.
      - `Lambda Calculus`: 1930년대 Alonzo Church 수학자에 의해 개발됨.
        - 람다 계산법에서 불변성(Immutability)은 매우 중요한 개념.
        - 람다 계산법에서 함수는 입력값을 가지고 출력값을 계산. 이때, 함수의 입력값이나 내부 변수 등은 변경되지 않고 입력값을 받아 출력값을 계산한 뒤 반환.
          즉, 함수는 상태를 변경하지 않으며 입력값과 출력값만으로 동작.
      - 함수형 언어에는 할당문이 전형 없다. (변경할 수 있는 방법을 주기도 하지만 극히 제한적.) 
    - 함수형 프로그래밍 언어:
      - LISP
      - ML

`함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.`

</details>

`각 패러다임은 프로그래머에게서 권한을 박탈한다.` 

----
# 4
## 구조적 프로그래밍

<details><summary>증명</summary>

> Goodbye goto statement

`데이크스트라`는 수학의 `증명`(Proof | 证明) 원리를 통해 프로그래밍의 문제를 해결하고자 했다. 그리고 goto 문이 증명 원리를 사용하는데 걸림돌임을 발견하였다.
- 데이크스트라: Edsger Wyber Dijkstra(05.11.1930-08.06.2002)는 네덜란드 로테르담(Rotterdam) 출신의 컴퓨터 과학자
  - 구조적 프로그래밍 방법론을 제안함. 

증명시 분할 정복(divide and conquer) 접근법을 사용해야하지만 goto 문은 `분할 정복 접근법 사용을 불가능`하게 한다. 
- 분할 정복 사용 불가: 모듈을 작은 단위로 쪼개 재귀적으로 분해할 수 없게 되기에.
  - 모듈: 프로그래밍에서 특정 기능을 수행하는 코드의 논리적 단위.

goto문은 실행 흐름을 제한 없이 자유자재로 이동시킨다. 이는 프로그램의 구조를 이해하기 어렵게 만드는 요인이며 유지보수도 어렵게 만든다.
재귀적인 분석을 위해서는 goto문을 사용하지 않도록 해야 한다. 그 대신, 제어문과 함수 호출등을 이용하여 프로그램의 실행흐름을 구성해야 한다.
- `goto` (X) → `if/then/else`, `do/while` (O)

</details>

<details><summary>탄생</summary>

> 구조적 프로그래밍의 탄생

1. 데이크스트라
    - 제어구조(Control structure)만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화 할 수 있다.
2. 뵘, 야코피니
    - 모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 세가지 구조만으로 표현할 수 있다고 증명.

데이크스트라는 `모듈을 증명 가능케 하는 제어구조` == `모든 프로그램을 만들 수 있는 제어 구조의 최소 집합` 이라는 사실을 발견. 이는 구조적 프로그래밍을 탄생하게 만듬.

**최소 집합 minimum set 最小集合**  
제어구조의 최소 집합은 `순차`와 `조건문`
- 순차 (Sequential): 코드의 실행 방향이 위에서 아래로 순차적으로 한줄씩 실행된다.
- 조건문 (Conditional Statement): 특정 조건에 따라 특정 코드 블록이 실행된다. (`if-else`, `switch-case` etc)

</details>

<details><summary>구조적 분석, 구조적 설계</summary>

> Structural analysis & Structural design

**구조적 분석 structural analysis**  
시스템의 구조를 분해하고 모델링 하는 과정
- 소프트웨어 요구사항을 수집하고 분석.
- 시스템의 기능, 데이터 및 처리 방법을 문서화.
- Data Flow Diagram (DFD)

**구조적 설계 structural design**  
시스템의 구조를 설계하는 과정
- 구조적 분석 과정에서 얻은 정보를 토대로 설계.
- 시스템을 상위 수준에서부터 하위 수준으로 분해 → 모듈화 → 시스템 구조 설계
- 모듈간의 관계 파악

</details>

----
# 5
## 객체 지향 프로그래밍

*'좋은 아키텍처를 만드는 일을 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.'*

<details><summary>OOP 의 본질</summary>

> The Essence of Object-Oriented Programming

OOP 의 본질은 세 개의 항목중에서 어느것인가?

### 캡슐화
> Encapsulation

- 객체지향 언어가 아닌 절차지향 언어인 C 에서도 충분히 캡슐화 할 수 있음.
- 많은 객체지향 언어가 캡슐화를 거의 강제하지 않음.
  - 강제하지 않는 이유: 유연성, 개발 편의성, 호환성 등을 위해

### 상속
> Inheritance

- 변수와 함수를 하나의 유효 범위로 묶어 재정의 하는 것에 불과함.
- 객체지향 언어가 존재하지 않던 시기에도 충분히 가능했던 것.
  - 상속의 흉내 정도(데이터 구조 가면 씌우기), 편리하지는 않음. 

### 다형성
> Polymorphism

- C에서 포인터를 사용하여 다형성을 구현해 볼 수 있음. 하지만 위험성 높음.
- 플러그인 아키텍처(plugin architecture)
- 의존성 역전(dependency inversion)
  - 다형성은 의존성 역전을 가능하게 만들어 줌. 
    - `High-level modules → Low-level modules` 의 관계를 `High-level modules ← Low-level modules` 로
    - 이는 소스 코드 사이에 interface 를 추가함으로써 가능.
  - 절대적인 권한 부여: 소스 코드 의존성을 원하는 방향으로 설정 가능하도록 만들어 줌.
    - 제어흐름 방향을 따라야했던 한계로 부터 자유로워짐.

`OOP란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.`

</details>

---
# 6
## 함수형 프로그래밍

<details><summary> 람다 계산법 </summary>

> lambda calculus

람다 계산법은 함수형 프로그래밍의 핵심 개념.
- 알론조 처치(Alonzo Church)가 1930년대에 발명.
  - [알론조 처치(06.14.1903-08.11.1995)](https://plato.stanford.edu/entries/church/): 미국의 20세기 수학자.
- 람다 계산법은 함수를 `형식적으로 정의`하고 `함수를 조합`하는 표기법을 제공.
  - **형식적 정의**: 람다 표현식(lambda expression)의 형식으로 정의.
    - 람다 표현식의 구조: `λ<paremeters>.<function body>`
      - e.g. `λx y. x + y` 
  - **함수의 조합**: 람다 표현식을 이용하여 더 복잡한 함수를 구성.
    - 함수의 조합은 주로 두 가지 방법 [currying 과 higher-order functions](https://www.cs.cornell.edu/courses/cs312/2008sp/recitations/rec03.html) 방식으로 이루어짐.   
        - **커링(currying)**: 다수의 인자를 받는 대신, 함수를 하나의 인자만 받는 연속적인 호출로 변환 시키는 것.
        - **고차 함수(higher-order functions)**: 함수를 인자로 받아 다른 함수를 반환 or 함수를 인자로 받아 원하는 동작을 수행하는 함수를 반환시킴.
- `함수의 추상화`와 조합을 수학적으로 다룰 수 있도록 도와줌.
  - **함수의 추상화**: 함수형 프로그래밍에서 함수는 `일급 객체`(first-class citizen) 이기 때문에 함수를 추상화 할 수 있음.
    - 함수를 변수에 할당, 함수의 인자로 전달, 반환값으로 사용.
      - 변수에 할당 가능
        - 함수를 변수처럼 다루어 조합함으로써 높은 수준의 추상화 달성 가능.
      - 인자로 전달 가능
      - 반환값으로 사용 가능

</details>

<details><summary> 불변성 </summary>

> Immutability

`아키텍처를 고려할 때 불변성은 중요하다.`

불변성: 한 번 생성된 데이터는 그 값을 변경할 수 없다.
- 변수의 값을 변경하는 대신, 새로운 값을 생성하여 데이터를 다룸.
- 불변성은 함수형 프로그래밍에서 중요한 개념.

불변성은 실현 가능한가...?
- YES... 자원이 무한대라면
  - 무한한 저장 공간
  - 무한히 빠른 프로세서 속도
- 타협점은? 
  - 가변 컴포넌트와 불변 컴포넌트의 분리!

</details>

<details><summary>가변성의 분리</summary>

> Separation of Concerns

`아키텍트라면 동시성 문제에 지대한 관심을 가져야 한다.`

동시성 환경에서는 `가변성`보다 `불변성`이 선호된다.
- **가변성**
  - 변수, 데이터 값을 변경할 수 있음.
    - 가변 변수는 아래와 같은 문제를 초래.
      - 경합(race)
      - 교착(deadlock)
      - 동시 업데이트(concurrent update)
- **불변성**
  - 값의 예측 가능성과 안정성을 높여줌.

`애플리케이션을 제대로 구조화하려면 변수를 변경하려는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다는 것`
- 불변 컴포넌트에서 최대한 많은 처리를 담당하게 함. 반면, 가변 컴포넌트에서는 최대한 적은 처리가 이루어 지도록.

</details>

<details><summary> 규율 </summary>

각각의 패러다임은 규율을 부여한다. 이를 통해, 코드 작성하는 방식을 한정시킴.
- **구조적 프로그래밍** → 제어흐름의 직접적인 전환
  - goto 문 제거.
    - 선택 구조, 반복 구조 사용.
  - 흐름을 명확하게 함: 순차적인 제어 흐름.
- **객체 지향 프로그래밍** → 제어흐름의 간접적인 전환
  - 객체 단위로 구성. 메소드 호출을 통해 상호 작용 처리.
    - 코드의 재사용성, 확장성, 유지보수성 향상.
- **함수형 프로그래밍** → 변수 할당
  - 불변성 상태를 통해 코드의 예측 가능성, 테스트 용이성, 병렬 처리등을 향상.
    - 변수의 값이 변경되지 않음.
    - 함수의 호출이 늘 동일한 결과를 반환.

</details>

---
# 7
## SRP: 단일 책임 원칙

<details><summary>단일 책임 원칙에 대하여</summary>

`단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.` == `하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.`
- 모듈(模块): 함수와 데이터 구조로 구성된 `응집`된 집합.
    - **응집**: 모듈의 내부 구성 요소들이 얼마나 관련되어 있는지를 나타냄.  
      모듈 내부의 요소들이 밀접하게 관련되어 있어야 한다.
        - 응집도 높음: 내부 요소들이 서로 밀접하게 관련되어 있음.
          - 코드 수정이 수월함. 
        - 응집도 낮음: 내부 요소들이 서로 연관성이 적음.
          - 기능을 이해하기 어렵게 만듬.
          - 코드 수정을 어렵게 만듬.
- 액터: 시스템이 동일한 방식으로 변경되기를 원하는 사용자/이해관계자들

</details>

<details><summary>서로 다른 액터의 코드를 분리</summary>

서로 다른 액터가 의존하는 코드를 서로 분리해야 한다. 이를 어길 시 병합의 문제가 발생한다.
- 코드의 예시 (in python)
    ```python
    class Order:
        def __init__(self, items):
            self.items = items
            self.payment = Payment()
    
        def process_order(self):
            self.payment.charge()
            print("Order processed successfully!")


    class Payment:
        def __init__(self):
            self.amount = 10000

        def charge(self):
            print(f"Charging {self.amount} dollars...")
    ```
    Order 클래스와 Payment 클래스는 서로를 의존하고 있다.
    무언가를 변경하려 할 시 두 클래스를 같이 수정해줘야 하게 된다. 서로의 의존성을 분리해야 한다.

  - **해결책**: 메서드를 각기 다른 클래스로 이동시킴.
    - 각 클래스는 반드시 필요한 소스 코드만 갖도록 함.
    - **퍼사드 패턴(Facade Pattern)**:
      - Facade: `건물의 정면이나 입구` 
        - 건물의 내부 구조를 숨기고 단순한 입구만 보여주는 Facade 처럼, 복잡한 코드를 사용하기 쉬운 인터페이스로 감싸서 제공하는 것.
          - 건축: 간단한 현관문과 로비만 보여줌. 
          - 코드: (복잡한 시스템이나 라이브러리를 숨기고) 클래스, 메서드만 보여줌.
      - 내부 구조와 동작 방식을 알 필요 없이 필요한 메서드를 호출하여 사용.
      - 코드의 예시 (in python)    
        자동차 엔진 시동 키는 기능 
        ```python
          class Engine:
              def start(self):
              print("Engine started")

              def stop(self):
                  print("Engine stopped")

          class IgnitionSystem:
              def ignite(self):
              print("Ignition system ignited")

          class Battery:
              def power_on(self):
              print("Battery power on")

          class CarFacade:
              def __init__(self):
              self.engine = Engine()
              self.ignition_system = IgnitionSystem()
              self.battery = Battery()

              def start(self):
                  self.battery.power_on()
                  self.ignition_system.ignite()
                  self.engine.start()
            
              def stop(self):
                  self.engine.stop()
                  self.ignition_system.ignite()
                  self.battery.power_on()
          ```
          엔진을 켤 때 발생하는 복잡한 상호작용을 그대로 보여주지 않고, 단순화된 인터페이스로 제공한다.

</details>

---
# 8
## OCP: 개방-폐쇄 원칙

<details><summary>Open but Closed</summary>

`소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.`

- 신 기능을 추가할 때 기존 코드를 변경하지 않고 확장할 수 있어야 한다.  
  이상적인 변경량: 0 <br><br>

  아래의 방법 사용,
  1. `추상화`  
     추상화를 통홰 인터페이스를 정의, 구현체를 분리. 
  2. `다형성`  
     새로운 동작을 추가할 수 있도록 확장 가능한 구조를 만들도록 함.
  3. `의존성 역전 원칙(DIP)`  
     의존성을 `체계화` 함으로 변경량을 최소화.
     - 체계화: 시스템 내의 모든 `컴포넌트와 모듈 사이의 의존성을 명확`하게 정리.
       - 이를 위한 방법: 추상화 인터페이스, 느슨한 결합 구조, DI 디자인 패턴, 중재자 패턴 사용.  
  4. `단일 책임 원칙(SRP)`  
     서로 다른 목적으로 변경되는 요소를 적절히 분리 시킴.

아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 `기능을 분리`시켜야 한다.
- 분리한 기능 → `컴포넌트의 계층구조로 조직화`
    - 컴포넌트의 계층구조로 조직화:
      - 시스템을 작은 단위로 쪼갬.
        - UI 컴포넌트, 데이터 접근 컴포넌트 등. 
      - 다른 역할을 하는 컴포넌트의 계층을 구성함.
        - 각 컴포넌트의 역할과 책임이 명확하게 됨. 

</details>

<details><summary>추이 종속성</summary>

> Transitive Dependency 传递性依赖

OCP를 달성하기 위해 `추이종속성`을 최소화 해야 한다.
- **추이종속성**: 하나의 모듈이 다른 모듈에 의존할 때, 그 다른 모듈이 또 다른 모듈에 의존하는 형태.  
  <img width="300" alt="Transitive Dependency " src="https://user-images.githubusercontent.com/48475824/235440000-b31aea7b-75e4-4b28-8279-ec70cf3eb23f.png">

- 추이종속성을 없애기 위해 DIP 를 적용시킨다.

추이종속성은 시스템을 유지보수하거나 확장하기 어렵게 만든다.
- 유지보수 난이도 ↑:
  - A 모듈이 B 모듈에 의존, B 모듈이 C 모듈에 의존. C 모듈의 변경이 A 모듈에 영향을 끼침.
    - C 모듈 수정시, A, B 모두 수정해야 할 수 있음. 
- 확장 난이도 ↑:
  - 새로운 모듈이 추가되는 경우 또는 기존 모듈이 변경되는 경우 다른 모듈도 변경해야 함.

</details>

`OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.`

---
# 9
## LSP: 리스코프 치환 원칙

<details><summary>LSP</summary>

> Liskov Substitution Principle

하위 타입은 상위 타입을 치환할 수 있다.  
- `치환`: 상속 관계에 있는 클래스들은 서로 치환 가능해야 한다.
  - 하위 타입으로 교체하여도 문제 없이 동작해야 한다.
- 상속을 통한 코드 재사용.
   - 부모 클래스에서 정의한 필드와 메소드를 자식 클래스에서 재사용. 
     - 부모 클래스에서 정의한 메소드와 동일한 파라미터와 반환값을 가져야 함.

</details>

---
# 10
## ISP: 인터페이스 분리 원칙 

<details><summary>ISP</summary>

> Interface Segregation Principle 

인터페이스를 클라이언트가 필요로하는 만큼의 메서드와 기능을 가진 작은 단위로 분리.
- 클라이언트가 필요로 하지 않는 메서드는 포함 안되도록.
  - 불필요한 의존성이 제거되어 객체간의 결합도 ↓
- 변경이나 확장을 쉽게 만들어 준다.

</details>

---
# 11
## DIP: 의존성 역전 원칙

<details><summary>Dependency Inversion Principle | 依赖倒置原则</summary>

유연성이 극대화된 시스템 == `유연성이 추상(abstract)에 의존하며 구체(concretion)에는 의존하지 않는 시스템`
- `유연성이 극대화 된`: 변경과 확장에 대한 대처력이 높은
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 대신 추상화된 것에 의존해야 한다.
  - 구체적인 대상에는 의존해서는 안된다.
  - 추상 클래스등을 이용하여 상위 수준 모듈과 하위 수준 모듈 사이의 의존성을 역전시켜야 한다.
- `구체에는 의존하지 않는`: 구현이나 세부 구현에 해당하는 모듈
  - 구체적인 모듈이 다른 모듈에서 직접적으로 참조되어서는 안된다. 
  - 구체적인 모듈에 직접적으로 의존하게 되면 시스템의 유연성과 확장성이 떨어지게 된다.

</details>

<details><summary> Stable Abstractions | 안정된 추상화 | 稳定的抽象 </summary>

`인터페이스는 구현체보다 변동성이 낮다.`
- 구현체는 구체적인 타입으로 구현 세부사항을 갖고 있음.   
  반면 인터페이스는 메서드의 원형만을 정의한 타입, 세부 사항을 가지지 않는다.

||Interface|Concrete Type|
|---|---|---|
|Definition|Method 원형만을 정의<br>구현 세부사항 X|구체적인 타입<br>구현 세부사항 O|
|Creation|직접 생성 X|직접 생성 O|
|Mutiple Inheritance|O|X|
|Polymorphism|O|X|

### 안정된 소프트웨어 아키텍처를 만드는 실천법
안정된 소프트웨어 아키텍처 == `변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처`
1. 변동성이 큰 구체 클래스를 참조하지 말라.  
    > Don't refer to volatile concret classes.  
    > 别引用易变的具体实现类。
    - 그 대신 인터페이스 참조. (동적 타입, 정적 타입 모두 포함)
    - 추상 팩토리(Abstract Factory) 사용 할 것.
1. 변동성이 큰 구체 클래스로부터 파생하지 말라.
    > Don't derive from volatile concrete classes.  
    > 别从易变的具体实现类派生。
1. 구체 함수를 오버라이드 하지 말라.
    > Don't override concrete functions.  
    > 别覆盖具体实现的函数。
    - 구체 함수는 
1. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
    > Never mention the name of anything concrete and volatile.  
    > 别提任何的具体实现和易变类的名字。

</details>
