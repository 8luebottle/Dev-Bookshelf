# The Pragmatic Programmer

> 실용주의 프로그래머 程序员修炼之道

## Table of Contents

| Chapter  | Topic | Title                                |  Page   | Date |
| :------: | :---: | :----------------------------------- | :-----: | :--: |
| [01](#1) |       | 실용주의 철학                        | 001-036 |      |
|          |  01   | 당신의 인생이다                      |         |      |
|          |  02   | 고양이가 내 소스 코드를 삼켰어요     |         |      |
|          |  03   | 소프트웨어 엔트로피                  |         |      |
|          |  04   | 돌멩이 수프와 삶은 개구리            |         |      |
|          |  05   | 적당히 괜찮은 소프트웨어             |         |      |
|          |  06   | 지식 포트폴리오                      |         |      |
|          |  07   | 소통하라!                            |         |      |
| [02](#2) |       | 실용주의 접근법                      | 037-102 |      |
|          |  08   | 좋은 설계의 핵심                     |         |      |
|          |  09   | DRY: 중복의 해악                     |         |      |
|          |  10   | 직교성                               |         |      |
|          |  11   | 가역성                               |         |      |
|          |  12   | 예광탄                               |         |      |
|          |  13   | 프로토타입과 포스트잇                |         |      |
|          |  14   | 도메인 언어                          |         |      |
|          |  15   | 추정                                 |         |      |
| [03](#3) |       | 기본 도구                            | 103-144 |      |
|          |  16   | 일반 텍스트의 힘                     |         |      |
|          |  17   | 셸 가지고 놀기                       |         |      |
|          |  18   | 파워 에디팅                          |         |      |
|          |  19   | 버전 관리                            |         |      |
|          |  20   | 디버깅                               |         |      |
|          |  21   | 텍스트 처리                          |         |      |
|          |  22   | 엔지니어링 일지                      |         |      |
| [04](#4) |       | 실용주의 편집증                      | 145-180 |      |
|          |  23   | 계약에 의한 설계                     |         |      |
|          |  24   | 죽은 프로그램은 거짓말을 하지 않는다 |         |      |
|          |  25   | 단정적 프로그래밍                    |         |      |
|          |  26   | 리소스 사용의 균형                   |         |      |
|          |  27   | 헤드라이트를 앞서가지 말라           |         |      |
| [05](#5) |       | 구부러지거나 부러지거나              | 181-240 |      |
|          |  28   | 결합도 줄이기                        |         |      |
|          |  29   | 실세계를 갖고 저글링하기             |         |      |
|          |  30   | 변환 프로그래밍                      |         |      |
|          |  31   | 상속세                               |         |      |
|          |  32   | 설정                                 |         |      |
| [06](#6) |       | 동시성                               | 241-272 |      |
|          |  33   | 시간적 결합 깨트리기                 |         |      |
|          |  34   | 공유 상태는 틀린 상태                |         |      |
|          |  35   | 액터와 프로세스                      |         |      |
|          |  36   | 칠판                                 |         |      |
| [07](#7) |       | 코딩하는 동안                        | 273-348 |      |
|          |  37   | 파충류의 뇌에 귀 기울이기            |         |      |
|          |  38   | 우연에 맡기는 프로그래밍             |         |      |
|          |  39   | 알고리즘의 속도                      |         |      |
|          |  40   | 리팩터링                             |         |      |
|          |  41   | 테스트로 코딩하기                    |         |      |
|          |  42   | 속성 기반 테스트                     |         |      |
|          |  43   | 바깥에서는 안전에 주의하라           |         |      |
|          |  44   | 이름 짓기                            |         |      |
| [08](#8) |       | 프로젝트 전에                        | 349-376 |      |
|          |  45   | 요구 사항의 구렁텅이                 |         |      |
|          |  46   | 불가능한 퍼즐 풀기                   |         |      |
|          |  47   | 함께 일하기                          |         |      |
|          |  48   | 애자일의 핵심                        |         |      |
| [09](#9) |       | 실용주의 프로젝트                    | 377-406 |      |
|          |  49   | 실용주의 팀                          |         |      |
|          |  50   | 코코넛만으로는 부족하다              |         |      |
|          |  51   | 실용주의 시작 도구                   |         |      |
|          |  52   | 사용자를 기쁘게 하라                 |         |      |
|          |  53   | 오만과 편견                          |         |      |

---

# 1

## 실용주의 철학

> A Pragmatic Philosophy 务实的哲学

<details><summary>소통하라!</summary>

> Communicate! 交流！

실용적인 발상과 훌륭한 아이디어는 소통 없이는 아무 효용이 없다.

개발자는 여러 입장에서 소통할 수 있어야 한다.

### 청중을 알라
- 청중에 맞추어 전달하려는 내용을 잘 전달하고 있는가?
- 청중의 요구, 관심, 그리고 능력 이해하기.
- 피드백 모으기.
  - 질문을 기다리기보단 먼저 묻기.

### 말하고 싶은 게 무엇인지 알라
> `상대가 무엇을 원하는지 알았다면 원하는 것을 이루어 주자.`
- 무엇을 말할지 미리 계획하기.
  - 개요 작성.
  - 자문.
  - 내용 다듬기.

### 때를 골라라
- 청중이 듣기 적합한 때를 골라야 한다. 말하는 시점도 중요.

### 스타일을 골라라
- 청중에 알맞는 전달 스타일을 고르자.
- 상대방의 기술 수준 파악하기.
  - 전문가? 신참? etc.

### 멋져 보이게 하라
- 매력적이게 보이도록 하는 것도 중요.
  - 스타일과 레이아웃 신경쓰기.
  - 맞춤법 확인.
  - 일관된 결과물 만들기.

### 청중을 참여시켜라
- 가능하다면 독자가 문서 초안에 참여하도록 할것.
  - 피드백 받기.
  - 요구 사항 확인하기.

### 경청하라
- 경청 받고 싶으면 우선 경청해줄 것.
- 회의를 대화로 바꾸는 것도 좋은 방법.

### 응답하라
- 이메일과 음성 메시지에 답 빼먹지 말고 할 것.
  - 그냥 넘어가는 무례함을 범하지 않기.

### 문서화
- 문서작업은 불가피하기 해야 할 일이 아니다.
  - `문서를 애초부터 포함하고, 나중에 집어넣으려고 하지 말라.`
- 외부로 노출하는 함수에는 주석을 달자.
- 코드의 주석:
  - 코드의 용도와 목적.
  - e.g. 기술적인 절충점, 어떤 결정의 이유, 폐기한 다른 대안 etc.

</details>

---

# 3

## 기본 도구

> The Basic Tools 基础工具

<details><summary>디버깅</summary>

> Debugging 调试

### 디버깅의 심리

- 공략 마음가짐: 디버깅 == 문제 풀이
- 타인의 버그 발견 후 비난하는 것이 아닌 문제를 고치는데 주력할 것.

### 디버깅 사고방식

- 가장 속이기 쉬운 사람은 자기 자신이다. (Edward Bulwer-Lytton)
  - 근시안 벗어나기:
    - 한 발짝 물러나 버그라고 생각하는 증상의 원인이 무엇인지 생각할 것.
    - 실제 문제는 표면에 보이지 않을 수 있다는 것을 염두에 둘 것.
    - 문제의 근본 원인을 찾고자 할 것.

### 실마리 찾기

- 빌드부터:
  - 디버깅 전 문제 없이 빌드되는 지 확인할 것.
  - 컴파일러 경고 수준 제일 높게 맞추기.
    - 컴퓨터가 대신 찾아 줄 수 있는 문제를 찾아줌으로써 시간 낭비를 줄여주기 때문.
- 관련 자료 모으기:
  - 버그를 보고한자로부터 받은 자료가 불확실/불충분할 경우 필요한 자료 재요구 할 것.
- 경계조건과 최종 사용자의 사용 패턴 모두 테스트 할 것.

### 디버깅 전략

- 버그 재현하기:
  - 제일 좋기로는 `명령어 하나` 로 재현 할 수 있도록 하기.
    - 버그 재현을 위한 단계를 최대한 줄이는 것이 좋다.
- 실패하는 테스트 작성:
  - 실패하는 상황과 그렇지 않은 상황을 분리하는 것은 통찰력을 선사함.
- 오류 메시지 제발 읽을것!
- 이러한 상황엔 이렇게:

  - 이상한 결과:
    - 디버거를 붙여 실패하는 테스트를 이용하여 문제를 재현하며 풀어가기.
    - 디버거에 잘못된 값이 존재하는가?
    - 디버거에서 `호출 스택 이동` 및 `스택의 지역변수 확인하는 법`에 관해 숙달해 놓기.
    - 메모하며 풀기.
      - 추적용: 시간 낭비를 줄여줌.
  - 입력값에 따라 바뀔 때:
    - 이진분할 사용:
      - 스택 프레임을 하나하나 보는 것 보다 더 빠른 방법일 수 있음.
  - 릴리즈 사이에 발생한 문제:
    - 이진분할 사용하기.
      - 분할 정복(divide and conquer)

- 그외의 방법:

  - 로깅과 트레이싱
    - 로깅 메시지는 규칙적이고 일관되게 작성 할 것.
      - 메시지 자동 분석에 도움이 됨.
  - 고무 오리
  - 소거법

- 가정하지 말고 증명할 것.

  - 버그를 고치는데서 끝나서는 안된다.
    - 자문하기:
      - 왜 이 문제가 더 일찍 발견되지 않았을까?
      - 해당 버그를 수정하는데 왜 오랜시간이 걸렸을까?
      - 비슷한 버그가 존재하지 않을까?
      - 다음번에는 어떻게 더 쉽게 고칠 수 있지?
    - 테스트 작성하기.
    - 토론하기:
      - 누군가의 잘못된 가정으로 발생한 버그라면 팀과 함께 토론하기. (다른 팀원들도 동일한 실수를 방지시키기 위해)

- 디버깅 체크리스트 작성하기.

</details>

<details><summary>엔지니어링 일지</summary>
> Engineering Daybooks 工程日记

- 일지가 주는 장점:
  - 기억보단 기록이 더 믿을만함.
  - 진행중인 작업과 직접적인 관계가 없는 발상을 쌓아 둘 수 있음.
    - 진행중인 일 먼저 작업 이후에 잊지 않고 처리하는데 도움됨.
  - 고무 오리와 같은 역할.
    - 작업하던 일을 돌아 볼 수 있게 해줌.
  - 과거의 내가 어떤 일을 했는지 알 수 있게 해줌.

</details>
