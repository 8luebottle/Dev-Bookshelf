# The Pragmatic Programmer

> 실용주의 프로그래머 程序员修炼之道

## Table of Contents

| Chapter  | Topic | Title                                |  Page   | Date |
| :------: | :---: | :----------------------------------- | :-----: | :--: |
| [01](#1) |       | 실용주의 철학                        | 001-036 |      |
|          |  01   | 당신의 인생이다                      |         |      |
|          |  02   | 고양이가 내 소스 코드를 삼켰어요     |         |      |
|          |  03   | 소프트웨어 엔트로피                  |         |      |
|          |  04   | 돌멩이 수프와 삶은 개구리            |         |      |
|          |  05   | 적당히 괜찮은 소프트웨어             |         |      |
|          |  06   | 지식 포트폴리오                      |         |      |
|          |  07   | 소통하라!                            |         |      |
| [02](#2) |       | 실용주의 접근법                      | 037-102 |      |
|          |  08   | 좋은 설계의 핵심                     |         |      |
|          |  09   | DRY: 중복의 해악                     |         |      |
|          |  10   | 직교성                               |         |      |
|          |  11   | 가역성                               |         |      |
|          |  12   | 예광탄                               |         |      |
|          |  13   | 프로토타입과 포스트잇                |         |      |
|          |  14   | 도메인 언어                          |         |      |
|          |  15   | 추정                                 |         |      |
| [03](#3) |       | 기본 도구                            | 103-144 |      |
|          |  16   | 일반 텍스트의 힘                     |         |      |
|          |  17   | 셸 가지고 놀기                       |         |      |
|          |  18   | 파워 에디팅                          |         |      |
|          |  19   | 버전 관리                            |         |      |
|          |  20   | 디버깅                               |         |      |
|          |  21   | 텍스트 처리                          |         |      |
|          |  22   | 엔지니어링 일지                      |         |      |
| [04](#4) |       | 실용주의 편집증                      | 145-180 |      |
|          |  23   | 계약에 의한 설계                     |         |      |
|          |  24   | 죽은 프로그램은 거짓말을 하지 않는다 |         |      |
|          |  25   | 단정적 프로그래밍                    |         |      |
|          |  26   | 리소스 사용의 균형                   |         |      |
|          |  27   | 헤드라이트를 앞서가지 말라           |         |      |
| [05](#5) |       | 구부러지거나 부러지거나              | 181-240 |      |
|          |  28   | 결합도 줄이기                        |         |      |
|          |  29   | 실세계를 갖고 저글링하기             |         |      |
|          |  30   | 변환 프로그래밍                      |         |      |
|          |  31   | 상속세                               |         |      |
|          |  32   | 설정                                 |         |      |
| [06](#6) |       | 동시성                               | 241-272 |      |
|          |  33   | 시간적 결합 깨트리기                 |         |      |
|          |  34   | 공유 상태는 틀린 상태                |         |      |
|          |  35   | 액터와 프로세스                      |         |      |
|          |  36   | 칠판                                 |         |      |
| [07](#7) |       | 코딩하는 동안                        | 273-348 |      |
|          |  37   | 파충류의 뇌에 귀 기울이기            |         |      |
|          |  38   | 우연에 맡기는 프로그래밍             |         |      |
|          |  39   | 알고리즘의 속도                      |         |      |
|          |  40   | 리팩터링                             |         |      |
|          |  41   | 테스트로 코딩하기                    |         |      |
|          |  42   | 속성 기반 테스트                     |         |      |
|          |  43   | 바깥에서는 안전에 주의하라           |         |      |
|          |  44   | 이름 짓기                            |         |      |
| [08](#8) |       | 프로젝트 전에                        | 349-376 |      |
|          |  45   | 요구 사항의 구렁텅이                 |         |      |
|          |  46   | 불가능한 퍼즐 풀기                   |         |      |
|          |  47   | 함께 일하기                          |         |      |
|          |  48   | 애자일의 핵심                        |         |      |
| [09](#9) |       | 실용주의 프로젝트                    | 377-406 |      |
|          |  49   | 실용주의 팀                          |         |      |
|          |  50   | 코코넛만으로는 부족하다              |         |      |
|          |  51   | 실용주의 시작 도구                   |         |      |
|          |  52   | 사용자를 기쁘게 하라                 |         |      |
|          |  53   | 오만과 편견                          |         |      |

---

# 1

## 실용주의 철학

> A Pragmatic Philosophy 务实的哲学

<details><summary>소프트웨어 엔트로피</summary>

> Software Entropy 软件的熵

- Software Entropy  
  소프트웨어의 복잡성이나 무질서도를 측정하는 메트릭.
  - Entropy: 시스템/데이터의 무질서도.
    - 엔트로피 높음: 무질서함이 높음
      - 유지보수 난이도 ↑
      - 버그 발생 ↑
      - 확장 난이도 ↑
    - 엔트로피 낮음: 정돈되고 구조화된 상태

소프트웨어 무질서도가 증가하면서 소프트웨어 부패가 심해진다.

- 소프트웨어 부패 == 기술 부채

소프트웨어에서도 깨진창문 이론이 적용된다.

- 소프트웨어에서의 깨진 창문:

  - 나쁜 설계.
  - 잘못된 결정.
  - 형편없는 코드.
  - 경영상의 잘못된 결정.

- '나중에'란 없다, 발견한 즉시 깨진 창문을 수리해야 한다.
  - 고칠 시간 부족: 판자로 덮어두기라도 하기
    - 주석처리, dummy 데이터로 교체 등
- 방치는 부패를 가속화 시킴.

</details>

<details><summary>적당히 괜찮은 소프트웨어</summary>

> Good-Enough Software 够好即可的软件

필요 이상으로 소프트웨어를 좋게 만드려다 되려 망칠 수 있다, `적당히 괜찮은` 소프트웨어를 만들도록 해보자.

- 적당히 괜찮은:

  - 짧은 작업기간 안에 만든, 마음에 평화를 유지할 수 있는 수준.

- 생각해보기:
  1. 사용자는 모든 버그를 제거할 때까지 기다릴 수 있을까?
  1. 복잡한 소프트웨어를 사용하면서 어느 정도의 버그는 감내할까?
  1. 아니면 결함이 더 적은 간단한 소프트웨어를 선택할까?

### 타협 과정에 사용자를 참여시켜라

- 소프트웨어가 얼마나 좋아야 하는지?
- 품질을 요구 사항으로 만들어라.
- 주의할 점: 불가능한 시간 약속을하지 않기.
  - 시스템 풀질 저하.
  - 되려 기본적인 것이 빠질 수 도 있음.
  - 전문가답지 못함.

### 멈춰야 할 때를 알라

- 프로그래밍은 그림 그리기와 유사하다.
  - 세부 묘사를 멈추지 않고 지속하고 지속하다보면 그림이 망가지듯 완벽해 보이지 않는 프로그램이더라도 적당한 때 작업을 멈추자.
- 기능 블로트(feature bloat)를 주의할 것.
  - 필요 이상의 많은 기능 == 늘어나는 버그 및 높아지는 보안 취약점
    - 복잡한 사용자 인터페이스.
    - 학습 곡선의 증가.
    - 유지보수 비용의 증가.
  - 기능 블로트 방지하는 법:
    - 핵심 기능에 집중.
    - 사용자의 요구를 이해할 것.

</details>

<details><summary>소통하라!</summary>

> Communicate! 交流！

실용적인 발상과 훌륭한 아이디어는 소통 없이는 아무 효용이 없다.

개발자는 여러 입장에서 소통할 수 있어야 한다.

### 청중을 알라

- 청중에 맞추어 전달하려는 내용을 잘 전달하고 있는가?
- 청중의 요구, 관심, 그리고 능력 이해하기.
- 피드백 모으기.
  - 질문을 기다리기보단 먼저 묻기.

### 말하고 싶은 게 무엇인지 알라

> `상대가 무엇을 원하는지 알았다면 원하는 것을 이루어 주자.`

- 무엇을 말할지 미리 계획하기.
  - 개요 작성.
  - 자문.
  - 내용 다듬기.

### 때를 골라라

- 청중이 듣기 적합한 때를 골라야 한다. 말하는 시점도 중요.

### 스타일을 골라라

- 청중에 알맞는 전달 스타일을 고르자.
- 상대방의 기술 수준 파악하기.
  - 전문가? 신참? etc.

### 멋져 보이게 하라

- 매력적이게 보이도록 하는 것도 중요.
  - 스타일과 레이아웃 신경쓰기.
  - 맞춤법 확인.
  - 일관된 결과물 만들기.

### 청중을 참여시켜라

- 가능하다면 독자가 문서 초안에 참여하도록 할것.
  - 피드백 받기.
  - 요구 사항 확인하기.

### 경청하라

- 경청 받고 싶으면 우선 경청해줄 것.
- 회의를 대화로 바꾸는 것도 좋은 방법.

### 응답하라

- 이메일과 음성 메시지에 답 빼먹지 말고 할 것.
  - 그냥 넘어가는 무례함을 범하지 않기.

### 문서화

- 문서작업은 불가피하기 해야 할 일이 아니다.
  - `문서를 애초부터 포함하고, 나중에 집어넣으려고 하지 말라.`
- 외부로 노출하는 함수에는 주석을 달자.
- 코드의 주석:
  - 코드의 용도와 목적.
  - e.g. 기술적인 절충점, 어떤 결정의 이유, 폐기한 다른 대안 etc.

</details>

---

# 2

## 실용주의 접근법

> A Pragmatic Approach 务实的方法

<details><summary>좋은 설계의 핵심</summary>

> The Essence of Good Design 优秀设计的精髓

`좋은 설계는 나쁜 설계보다 바꾸기 쉽다.`

### ETC는 규칙이 아니라 가치

> 가치: 결정을 내릴 수 있게 도움을 줌.

- ETC: Easier to Change 容易变更
  - 결합도 줄이기
  - 단일 책임 원칙 (single responsibility principle)
    - 모듈 하나만 바꾸면 됨.
  - 좋은 이름 짓기
    - 코드르 바꾸기 위해서는 코드를 읽어야 함. 좋은 이름 → 코드를 읽기 좋게 만듬.

**습관화 하기:**

- 코드 작성/변경 시 자신에게 질문: `'방금 적용한 부분으로 인해 전체 시스템을 바꾸기 쉽게 했을까? 아님 어렵게 만들었을까?'`

**현재 시스템, 코드의 요구사항 또는 기능이 어떤 모습으로 변화될 지 잘 모르겠을 경우:**

- ETC 의 길을 택할 것.
  - 모든 코드를 교체할 수 있게 작성. (극단적으로 보이더라도...)
  - 코드의 결합도 ↓
  - 응집도 ↑

</details>

<details><summary>직교성</summary>

> Orthogonality 正交性

<img src="https://github.com/8luebottle/Dev-Bookshelf/assets/48475824/984e63a1-a138-4cd3-941e-f8e75f79ddc0" alt="Orthogonality" title="Orthogonality" width="300">

- 직각으로 만나는 두 직선은(직교) 독립적이다.

  - 직교성을 지닌 기능은 독립적이어서 서로 영향을 주지 않는다.
  - 결합도 줄이기.
  - 종속성이 없으므로 유지보수가 수월함.
  - 자족적(self-contained)인 컴포넌트

- 관련 없는 것들 간에 서로 영향이 없도록 하라.

**직교적 시스템의 장점:**

- 생산성 향상

  - 고쳐야 하는 코드가 줄어들어 개발 시간과 테스트 시간이 줄어듬.
  - 높은 재사용성: 시스템이 느슨하게 결합되어 있으므로 재조합 및 개량이 쉬워짐.

- 리스크 감소

  - 감염된 코드가 격리되어 있음.
  - 시스템이 잘 꺼지지 않음.
  - 테스트 설계/실행이 수월함.
  - 제품/플랫폼에 덜 종속됨.

**설계:**

- 설계가 직교적인지 확인하는 법:
  - `특정 기능에 대한 요구 사항을 변경하는 경우 몇 개의 모듈이 영향을 받는가?`
    - 직교적이라면 답은 하나, 아니라면 여러개.

**툴킷과 라이브러리**

- 외부 툴을 도입시 주의해야 한다. 툴킷이나 라이브러리가 시스템의 직교성을 해치지는 않는지 확인 필요.

**코딩:**

> 코딩시 직교성 유지하는 법

- 코드의 결합도 줄이기
  - 부끄럼쟁이 코드 작성하기.
    - 불필요한 것은 다른 모듈에 보여주지 X.
    - 다른 모듈에 의존하지 않는 코드 작성하기.
- 전역 데이터 피하기
  - 전역 데이터를 참조한다는 것은 해당 데이터를 공유하는 다른 컴포넌트와 묶인다는 것.
  - 싱글턴 사용도 주의. 불필요한 결합을 만들 수 있음.
- 유사한 함수 피하기.
  - 중복된 코드는 문제가 있다는 증거.

Refactoring: 자신이 작성하는 코드를 항상 비판적으로 바라보고 코드의 구조와 직교성을 위해 노력할 것.

</details>

<details><summary>추정</summary>

> Estimating 估算

추정하는 법 배우기, 추정 능력 개발하기.

### 얼마나 정확해야 충분히 정확한가?

> 추정의 답변의 단위는 아래 처럼

| 기간       | 추정의 단위       |
| ---------- | ----------------- |
| 1-15 일    | 일                |
| 3-6 주     | 주                |
| 8-20 주    | 달                |
| 20 주 이상 | 다시 생각해 볼 것 |

### 추정치는 어디에서 나오는가?

추정 비법:

- 관련 일을 해본적 있는 사람에게 물어보기.

- 무엇을 묻고 있는지 이해하라

  - 상대가 무엇을 묻고 있는가?
  - 도메인에 존재하는 조건(scope)에 대해 알기.

- 시스템의 모델을 만들어라

  - 시스템을 어떻게 구현하느냐에 관한 밑그림.
  - 해당 과정에서 미처 몰랐던 패턴이나 프로세스를 발견할 수도 있음.

- 모델을 컴포넌트로 나눠라

  - 컴포넌트로 분해.
  - 컴포넌트들의 상호작용을 수식으로 기술.

- 각 매개 변수에 값을 할당하라

  - 컴포넌트의 매개변수.
  - 매개변수의 값을 최대한 정확히 산출해 내기.

- 답을 계산하라

  - 주요 매개 변수들의 값을 바꾸어가며 계산해보기.

- 여러분의 추정 실력을 기록하라

  - 계산했던 추정치를 기록해놓고 나중에 비교해보자. 추정 값이 실제 결과와 얼마나 비슷했는가?
    - 오차 범위가 큰 경우: 왜? 무엇때문에 범위가 이렇게 벌어지게 되었을까?

### 프로젝트 일정 추정하기

> 불확실성을 줄이는 방법 알아보기.

- 프로그램 평가 검토 기법(Program Evaluation Review Technique)

  - 낙관적 추정치(Optimistic Estimate):
    - 가장 이상적 조건에서 소요되는 최소 시간으로 예상되는 값.
  - 비관적 추정치(Pessimistic Estimate):
    - 예상대로 진행되지 않을 경우 소요되는 최대 시간으로 예상되는 값.
  - 기대값(Expected Value):
    - 낙관적 추정치와 비관적 추정치 사의의 중간 값.

- 요구사항 확인하기.
- 위험을 분석하고 위험도가 높은 부분을 우선 하기.
- 설계, 구현, 통합.
- 사용자와 함께 검증하기.

어찌되었건 해본적이 없는 프로젝트라면 어림짐작 일정이기 마기.

- 초기 기능 구현, 테스트 이후 이를 첫번째 반복 주기로 삼을것. → 반복 및 조정

</details>

---

# 3

## 기본 도구

> The Basic Tools 基础工具

<details><summary>셸 가지고 놀기</summary>

목수의 작업대처럼 프로그래머의 작업대는 shell 이다.

- `GUI의 환경의 기능은 일반적으로 설계자가 의도한 범위를 넘어설 수 없다.`

  - GUI 장점: WYSIWYG (What You See Is What You Get)
  - GUI 단점: WYSIAYG (What You See Is All You Get)

- Shell 에 익숙해지면 생산성도 상승한다.
  - 자동화와 스크립팅
  - 강력한 명령어
    - 복잡한 작업을 단일 명령어로
  - 리소스 효율성
    - 텍스트 기반
  - 빠른 작업 흐름

</details>

<details><summary>디버깅</summary>

> Debugging 调试

### 디버깅의 심리

- 공략 마음가짐: 디버깅 == 문제 풀이
- 타인의 버그 발견 후 비난하는 것이 아닌 문제를 고치는데 주력할 것.

### 디버깅 사고방식

- 가장 속이기 쉬운 사람은 자기 자신이다. (Edward Bulwer-Lytton)
  - 근시안 벗어나기:
    - 한 발짝 물러나 버그라고 생각하는 증상의 원인이 무엇인지 생각할 것.
    - 실제 문제는 표면에 보이지 않을 수 있다는 것을 염두에 둘 것.
    - 문제의 근본 원인을 찾고자 할 것.

### 실마리 찾기

- 빌드부터:
  - 디버깅 전 문제 없이 빌드되는 지 확인할 것.
  - 컴파일러 경고 수준 제일 높게 맞추기.
    - 컴퓨터가 대신 찾아 줄 수 있는 문제를 찾아줌으로써 시간 낭비를 줄여주기 때문.
- 관련 자료 모으기:
  - 버그를 보고한자로부터 받은 자료가 불확실/불충분할 경우 필요한 자료 재요구 할 것.
- 경계조건과 최종 사용자의 사용 패턴 모두 테스트 할 것.

### 디버깅 전략

- 버그 재현하기:
  - 제일 좋기로는 `명령어 하나` 로 재현 할 수 있도록 하기.
    - 버그 재현을 위한 단계를 최대한 줄이는 것이 좋다.
- 실패하는 테스트 작성:
  - 실패하는 상황과 그렇지 않은 상황을 분리하는 것은 통찰력을 선사함.
- 오류 메시지 제발 읽을것!
- 이러한 상황엔 이렇게:

  - 이상한 결과:
    - 디버거를 붙여 실패하는 테스트를 이용하여 문제를 재현하며 풀어가기.
    - 디버거에 잘못된 값이 존재하는가?
    - 디버거에서 `호출 스택 이동` 및 `스택의 지역변수 확인하는 법`에 관해 숙달해 놓기.
    - 메모하며 풀기.
      - 추적용: 시간 낭비를 줄여줌.
  - 입력값에 따라 바뀔 때:
    - 이진분할 사용:
      - 스택 프레임을 하나하나 보는 것 보다 더 빠른 방법일 수 있음.
  - 릴리즈 사이에 발생한 문제:
    - 이진분할 사용하기.
      - 분할 정복(divide and conquer)

- 그외의 방법:

  - 로깅과 트레이싱
    - 로깅 메시지는 규칙적이고 일관되게 작성 할 것.
      - 메시지 자동 분석에 도움이 됨.
  - 고무 오리
  - 소거법

- 가정하지 말고 증명할 것.

  - 버그를 고치는데서 끝나서는 안된다.
    - 자문하기:
      - 왜 이 문제가 더 일찍 발견되지 않았을까?
      - 해당 버그를 수정하는데 왜 오랜시간이 걸렸을까?
      - 비슷한 버그가 존재하지 않을까?
      - 다음번에는 어떻게 더 쉽게 고칠 수 있지?
    - 테스트 작성하기.
    - 토론하기:
      - 누군가의 잘못된 가정으로 발생한 버그라면 팀과 함께 토론하기. (다른 팀원들도 동일한 실수를 방지시키기 위해)

- 디버깅 체크리스트 작성하기.

</details>

<details><summary>엔지니어링 일지</summary>
> Engineering Daybooks 工程日记

- 일지가 주는 장점:
  - 기억보단 기록이 더 믿을만함.
  - 진행중인 작업과 직접적인 관계가 없는 발상을 쌓아 둘 수 있음.
    - 진행중인 일 먼저 작업 이후에 잊지 않고 처리하는데 도움됨.
  - 고무 오리와 같은 역할.
    - 작업하던 일을 돌아 볼 수 있게 해줌.
  - 과거의 내가 어떤 일을 했는지 알 수 있게 해줌.

</details>

---

# 4

## 실용주의 편집증 务实的偏执

> Pragmatic Paranoia

완벽한 소프트웨어는 만들 수 없다.

방어운전을 하듯 방어적으로 코딩을 해야한다. 하지만 이로써는 부족하다. 실용주의 프로그래머는 자기 자신 역시 믿지 않아야한다. 이는 자신의 실수에 대비하여 방어책을 만들어 놓는것을 의미한다.

<details><summary>계약에 의한 설계</summary>

> Design by Contract 契约式设计

정직한 거래 보장하는 법: 계약

### DBC

> Design By Contract 계약에 의한 설계

- 프로그램의 정확성을 확보.

  - 정확성: 자신이 하는 일이라고 주장하는 것보다 많지도 적지도 않게 딱 그만큼만 하는 프로그램.

- 선행조건(Precondition)

  - 메서드/함수가 호출되기 전에 만족해야하는 조건.
  - 조건 위반시 호출되지 않아야 함.
  - 호출자:
    - 제대로 된 데이터 전달하기.
    - 호출 순서, 상태에 대한 요구사항 명시.

- 후행조건(Postcondition)

  - 루틴이 끝난 후에 보장되어야 하는 조건.
  - 무한반복은 허용되지 않음.
  - 함수/메서드 반환값이나 상태 변경과 관련된 요구사항 명시.

- 클래스 불변식(Class Invariant)

  - 클래스의 객체가 생성되고 유지되는 동안 만족해야하는 조건.
  - 객체의 상태와 관련된 불변적 특성을 명시.
    - 객체의 특정 속성은 항상 유지되어야 한다.

- DBC를 잘 지원하는 언어: Clojure

  - Clojure 언어의 특성
    - Assert 매크로
      - assert 매크로를 통해 사전조건, 사후조건을 검사.
    - Spec 시스템
      - 데이터의 구조와 유효성 검사.
    - Immutable 데이터
      - 불변성을 가진 데이터 구조를 강조. 클래스 불변식을 유지할 수 있도록 도움.
    - REPL 환경

- 게으름뱅이 코드: `시작하기 전에 자신이 수용할 것은 엄격하게 확인하고, 내어 줄 것에 대해서는 최소한도를 약속하는 것.`

- DBC Vs. TDD

  > DBC 와 TDD 모두 가치있는 방법론이다.

  |                  | DBC                                               | TDD                                             |
  | ---------------- | ------------------------------------------------- | ----------------------------------------------- |
  | Concept          | 컴포넌트 간의 계약을 기반                         | 테스트를 중심으로 개발                          |
  | Goal             | 소프트웨어의 정확성과 신뢰성 확보                 | 버그를 줄이고 안정적인 소프트웨어 개발          |
  | Focus            | 사전조건, 사후조건, 클래스 불변식에 초점          | 테스트 케이스 작성 및 검증 중심                 |
  | Testing          | 컴포넌트의 사전조건과 사후조건 검증을 중심으로 함 | 테스트 케이스 작성 및 검증을 중심으로 함        |
  | Purpose          | 코드의 정확성과 신뢰성을 확보하기 위함            | 코드의 품질을 향상시키고 버그를 최소화하기 위함 |
  | Execution Timing | 설계 단계에서 계약 명시 및 검증                   | 개발 단계에서 테스트 케이스 작성 및 검증을 진행 |
  | Advantages       | 정확성과 신뢰성을 높일 수 있음                    | 코드 품질 향상 및 초기 버그 발견 가능           |
  | Disadvantages    | 컨트랙트 작성 및 유지에 추가적인 비용 발생        | 테스트 케이스 작성에 추가적인 시간과 노력 필요  |

- DBC 구현

  - 코드 작성전 생각하기:

    - 유효한 입력 범위는?
    - 경계 조건(Boundary Condition)은?
      - 입력, 출력, 동작 범위의 끝 부분에 해당하는 조건
    - 루틴은 무엇을 전달할까?

  - 단정문:
    - 프로그램의 특정 지점에서 조건을 검증. 해당 조건이 True 인지 확인.
    - 이를 통해 코드의 정확성을 검증, 예회 상황 식별.

- DBC와 일찍 멈추기

  - `문제를 찾고 원인을 밝히기 위해서는 사고가 난 지점에서 일찍 멈추는 것이 유리하다.`
    - 문제가 발생한 지점에서 바로 멈추어 추가 연산을 중단시킴.
    - 멈춘 부분에서부터 오류 분석, 원인 파악. 즉 조기에 발견하여 신속하게 대응하기 위함.

- 의미론적 불변식
  - 의미론적:
    - 조건이 프로그램의 의미 또는 의도에 부합하는지?
  - 불변식:
    - 프로그램의 실행 중에 변하지 않아야 하는 조건
  - 명확하고 모호한 점이 없도록 서술.

</details>
