# The Pragmatic Programmer

> 실용주의 프로그래머 程序员修炼之道

## Table of Contents

| Chapter  | Topic | Title                                |  Page   | Date |
| :------: | :---: | :----------------------------------- | :-----: | :--: |
| [01](#1) |       | 실용주의 철학                        | 001-036 |      |
|          |  01   | 당신의 인생이다                      |         |      |
|          |  02   | 고양이가 내 소스 코드를 삼켰어요     |         |      |
|          |  03   | 소프트웨어 엔트로피                  |         |      |
|          |  04   | 돌멩이 수프와 삶은 개구리            |         |      |
|          |  05   | 적당히 괜찮은 소프트웨어             |         |      |
|          |  06   | 지식 포트폴리오                      |         |      |
|          |  07   | 소통하라!                            |         |      |
| [02](#2) |       | 실용주의 접근법                      | 037-102 |      |
|          |  08   | 좋은 설계의 핵심                     |         |      |
|          |  09   | DRY: 중복의 해악                     |         |      |
|          |  10   | 직교성                               |         |      |
|          |  11   | 가역성                               |         |      |
|          |  12   | 예광탄                               |         |      |
|          |  13   | 프로토타입과 포스트잇                |         |      |
|          |  14   | 도메인 언어                          |         |      |
|          |  15   | 추정                                 |         |      |
| [03](#3) |       | 기본 도구                            | 103-144 |      |
|          |  16   | 일반 텍스트의 힘                     |         |      |
|          |  17   | 셸 가지고 놀기                       |         |      |
|          |  18   | 파워 에디팅                          |         |      |
|          |  19   | 버전 관리                            |         |      |
|          |  20   | 디버깅                               |         |      |
|          |  21   | 텍스트 처리                          |         |      |
|          |  22   | 엔지니어링 일지                      |         |      |
| [04](#4) |       | 실용주의 편집증                      | 145-180 |      |
|          |  23   | 계약에 의한 설계                     |         |      |
|          |  24   | 죽은 프로그램은 거짓말을 하지 않는다 |         |      |
|          |  25   | 단정적 프로그래밍                    |         |      |
|          |  26   | 리소스 사용의 균형                   |         |      |
|          |  27   | 헤드라이트를 앞서가지 말라           |         |      |
| [05](#5) |       | 구부러지거나 부러지거나              | 181-240 |      |
|          |  28   | 결합도 줄이기                        |         |      |
|          |  29   | 실세계를 갖고 저글링하기             |         |      |
|          |  30   | 변환 프로그래밍                      |         |      |
|          |  31   | 상속세                               |         |      |
|          |  32   | 설정                                 |         |      |
| [06](#6) |       | 동시성                               | 241-272 |      |
|          |  33   | 시간적 결합 깨트리기                 |         |      |
|          |  34   | 공유 상태는 틀린 상태                |         |      |
|          |  35   | 액터와 프로세스                      |         |      |
|          |  36   | 칠판                                 |         |      |
| [07](#7) |       | 코딩하는 동안                        | 273-348 |      |
|          |  37   | 파충류의 뇌에 귀 기울이기            |         |      |
|          |  38   | 우연에 맡기는 프로그래밍             |         |      |
|          |  39   | 알고리즘의 속도                      |         |      |
|          |  40   | 리팩터링                             |         |      |
|          |  41   | 테스트로 코딩하기                    |         |      |
|          |  42   | 속성 기반 테스트                     |         |      |
|          |  43   | 바깥에서는 안전에 주의하라           |         |      |
|          |  44   | 이름 짓기                            |         |      |
| [08](#8) |       | 프로젝트 전에                        | 349-376 |      |
|          |  45   | 요구 사항의 구렁텅이                 |         |      |
|          |  46   | 불가능한 퍼즐 풀기                   |         |      |
|          |  47   | 함께 일하기                          |         |      |
|          |  48   | 애자일의 핵심                        |         |      |
| [09](#9) |       | 실용주의 프로젝트                    | 377-406 |      |
|          |  49   | 실용주의 팀                          |         |      |
|          |  50   | 코코넛만으로는 부족하다              |         |      |
|          |  51   | 실용주의 시작 도구                   |         |      |
|          |  52   | 사용자를 기쁘게 하라                 |         |      |
|          |  53   | 오만과 편견                          |         |      |

---

# 1

## 실용주의 철학

> A Pragmatic Philosophy 务实的哲学

<details><summary>당신의 인생이다</summary>

> It’s Your Life 人生是你的

우리의 인생은 우리가 만들어야 한다. 불만에 갖혀있지 말고 변화를 시도하라.

구직자에게 주도권이 있는 직업 순위중 소프트웨어 개발자는 윗부분에 위치한다.

변화를 피하지 말고 직접 부딪혀라. 주도적으로 행동하여 기회를 잡기.

- 기술에 뒤쳐지는 것 같음 → 여가 시간을 쪼개 공부하기
- 원격 근무를 하고 싶음 → 가능한지 물어보기 → 다른 곳 찾기

</details>

<details><summary>소프트웨어 엔트로피</summary>

> Software Entropy 软件的熵

- Software Entropy  
  소프트웨어의 복잡성이나 무질서도를 측정하는 메트릭.
  - Entropy: 시스템/데이터의 무질서도.
    - 엔트로피 높음: 무질서함이 높음
      - 유지보수 난이도 ↑
      - 버그 발생 ↑
      - 확장 난이도 ↑
    - 엔트로피 낮음: 정돈되고 구조화된 상태

소프트웨어 무질서도가 증가하면서 소프트웨어 부패가 심해진다.

- 소프트웨어 부패 == 기술 부채

소프트웨어에서도 깨진창문 이론이 적용된다.

- 소프트웨어에서의 깨진 창문:

  - 나쁜 설계.
  - 잘못된 결정.
  - 형편없는 코드.
  - 경영상의 잘못된 결정.

- '나중에'란 없다, 발견한 즉시 깨진 창문을 수리해야 한다.
  - 고칠 시간 부족: 판자로 덮어두기라도 하기
    - 주석처리, dummy 데이터로 교체 등
- 방치는 부패를 가속화 시킴.

</details>

<details><summary>적당히 괜찮은 소프트웨어</summary>

> Good-Enough Software 够好即可的软件

필요 이상으로 소프트웨어를 좋게 만드려다 되려 망칠 수 있다, `적당히 괜찮은` 소프트웨어를 만들도록 해보자.

- 적당히 괜찮은:

  - 짧은 작업기간 안에 만든, 마음에 평화를 유지할 수 있는 수준.

- 생각해보기:
  1. 사용자는 모든 버그를 제거할 때까지 기다릴 수 있을까?
  1. 복잡한 소프트웨어를 사용하면서 어느 정도의 버그는 감내할까?
  1. 아니면 결함이 더 적은 간단한 소프트웨어를 선택할까?

### 타협 과정에 사용자를 참여시켜라

- 소프트웨어가 얼마나 좋아야 하는지?
- 품질을 요구 사항으로 만들어라.
- 주의할 점: 불가능한 시간 약속을하지 않기.
  - 시스템 풀질 저하.
  - 되려 기본적인 것이 빠질 수 도 있음.
  - 전문가답지 못함.

### 멈춰야 할 때를 알라

- 프로그래밍은 그림 그리기와 유사하다.
  - 세부 묘사를 멈추지 않고 지속하고 지속하다보면 그림이 망가지듯 완벽해 보이지 않는 프로그램이더라도 적당한 때 작업을 멈추자.
- 기능 블로트(feature bloat)를 주의할 것.
  - 필요 이상의 많은 기능 == 늘어나는 버그 및 높아지는 보안 취약점
    - 복잡한 사용자 인터페이스.
    - 학습 곡선의 증가.
    - 유지보수 비용의 증가.
  - 기능 블로트 방지하는 법:
    - 핵심 기능에 집중.
    - 사용자의 요구를 이해할 것.

</details>

<details><summary>지식 포트폴리오</summary>

> Your Knowledge Portfolio 知识组合

`지식에 대한 투자가 언제나 최고의 이윤을 낸다. - Benjamin Franklin`

지식과 경험은 중요한 자산이지만 기한이 있는 자산이다. 전략 자산으로서 새로운 것을 배우는 능력을 키워야 한다.

지식 포트폴리오는 투자 포트폴리오 관리와 유사.

- 주기적인 투자
  - 지식 향상을 위해 주기적으로 시간과 노력을 투자.
- 다각화
  - 여러 분야와 주제에 걸쳐 넓은 범위의 지식을 확보.
  - 현재 작업에 사용하는 기술에 관해서는 깊이있게 알아야 함.
- 리스크 관리
- 싸게 사서 비싸게 팔기
  - 저평가된 지식 찾기: 새롭게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습보기.
- 검토 및 재조정

### 목표

- 매년 새로운 언어를 최소 하나는 배워라.
  - 다른 언어는 동일한 문제를 다르게 풀기에 사고 확장에 도움이 됨.
- 기술 서적을 한 달에 한 권씩 읽어라.
  - 현재 프로젝트와 관련 있는 주제의 기술 서적을 읽기.
- 기술 서적이 아닌 책도 읽어라.
  - 사람에 관한 이해를 돕는 책.
- 수업을 들어라.
- 지역 사용자 단체나 모임에 참여하라.
  - 고립은 경력에 치명적.
  - 회사밖 사람들과의 네트워킹.
- 다른 환경에서 실험해 보라.
- 요즘 흐름을 놓치지 말라.
  - 기술 뉴스, 게시물 등.

배운 지식들을 교접하여, 현재 프로젝트에 적용해 보자.

### 비판적 사고

Input된 지식에 대해 비판적으로 분석하기.

- 왜냐고 다섯번 묻기
  - 왜라는 질문은 근본 원인에 가깝게 갈 수 있도록 한다.
- 누구에게 이익이 되나?
  - 돈의 흐름을 보면 분석이 쉬워짐.
- 어떤 맥락인가?
  - 전제 조건은 무엇인가?
  - 장기, 단기적 여파는 무엇인가?
- 언제 혹은 어디서 효과가 있을까?
- 왜 이것이 문제인가?

</details>

<details><summary>소통하라!</summary>

> Communicate! 交流！

실용적인 발상과 훌륭한 아이디어는 소통 없이는 아무 효용이 없다.

개발자는 여러 입장에서 소통할 수 있어야 한다.

### 청중을 알라

- 청중에 맞추어 전달하려는 내용을 잘 전달하고 있는가?
- 청중의 요구, 관심, 그리고 능력 이해하기.
- 피드백 모으기.
  - 질문을 기다리기보단 먼저 묻기.

### 말하고 싶은 게 무엇인지 알라

> `상대가 무엇을 원하는지 알았다면 원하는 것을 이루어 주자.`

- 무엇을 말할지 미리 계획하기.
  - 개요 작성.
  - 자문.
  - 내용 다듬기.

### 때를 골라라

- 청중이 듣기 적합한 때를 골라야 한다. 말하는 시점도 중요.

### 스타일을 골라라

- 청중에 알맞는 전달 스타일을 고르자.
- 상대방의 기술 수준 파악하기.
  - 전문가? 신참? etc.

### 멋져 보이게 하라

- 매력적이게 보이도록 하는 것도 중요.
  - 스타일과 레이아웃 신경쓰기.
  - 맞춤법 확인.
  - 일관된 결과물 만들기.

### 청중을 참여시켜라

- 가능하다면 독자가 문서 초안에 참여하도록 할것.
  - 피드백 받기.
  - 요구 사항 확인하기.

### 경청하라

- 경청 받고 싶으면 우선 경청해줄 것.
- 회의를 대화로 바꾸는 것도 좋은 방법.

### 응답하라

- 이메일과 음성 메시지에 답 빼먹지 말고 할 것.
  - 그냥 넘어가는 무례함을 범하지 않기.

### 문서화

- 문서작업은 불가피하기 해야 할 일이 아니다.
  - `문서를 애초부터 포함하고, 나중에 집어넣으려고 하지 말라.`
- 외부로 노출하는 함수에는 주석을 달자.
- 코드의 주석:
  - 코드의 용도와 목적.
  - e.g. 기술적인 절충점, 어떤 결정의 이유, 폐기한 다른 대안 etc.

</details>

---

# 2

## 실용주의 접근법

> A Pragmatic Approach 务实的方法

<details><summary>좋은 설계의 핵심</summary>

> The Essence of Good Design 优秀设计的精髓

`좋은 설계는 나쁜 설계보다 바꾸기 쉽다.`

### ETC는 규칙이 아니라 가치

> 가치: 결정을 내릴 수 있게 도움을 줌.

- ETC: Easier to Change 容易变更
  - 결합도 줄이기
  - 단일 책임 원칙 (single responsibility principle)
    - 모듈 하나만 바꾸면 됨.
  - 좋은 이름 짓기
    - 코드르 바꾸기 위해서는 코드를 읽어야 함. 좋은 이름 → 코드를 읽기 좋게 만듬.

**습관화 하기:**

- 코드 작성/변경 시 자신에게 질문: `'방금 적용한 부분으로 인해 전체 시스템을 바꾸기 쉽게 했을까? 아님 어렵게 만들었을까?'`

**현재 시스템, 코드의 요구사항 또는 기능이 어떤 모습으로 변화될 지 잘 모르겠을 경우:**

- ETC 의 길을 택할 것.
  - 모든 코드를 교체할 수 있게 작성. (극단적으로 보이더라도...)
  - 코드의 결합도 ↓
  - 응집도 ↑

</details>

<details><summary>직교성</summary>

> Orthogonality 正交性

<img src="https://github.com/8luebottle/Dev-Bookshelf/assets/48475824/984e63a1-a138-4cd3-941e-f8e75f79ddc0" alt="Orthogonality" title="Orthogonality" width="300">

- 직각으로 만나는 두 직선은(직교) 독립적이다.

  - 직교성을 지닌 기능은 독립적이어서 서로 영향을 주지 않는다.
  - 결합도 줄이기.
  - 종속성이 없으므로 유지보수가 수월함.
  - 자족적(self-contained)인 컴포넌트

- 관련 없는 것들 간에 서로 영향이 없도록 하라.

**직교적 시스템의 장점:**

- 생산성 향상

  - 고쳐야 하는 코드가 줄어들어 개발 시간과 테스트 시간이 줄어듬.
  - 높은 재사용성: 시스템이 느슨하게 결합되어 있으므로 재조합 및 개량이 쉬워짐.

- 리스크 감소

  - 감염된 코드가 격리되어 있음.
  - 시스템이 잘 꺼지지 않음.
  - 테스트 설계/실행이 수월함.
  - 제품/플랫폼에 덜 종속됨.

**설계:**

- 설계가 직교적인지 확인하는 법:
  - `특정 기능에 대한 요구 사항을 변경하는 경우 몇 개의 모듈이 영향을 받는가?`
    - 직교적이라면 답은 하나, 아니라면 여러개.

**툴킷과 라이브러리**

- 외부 툴을 도입시 주의해야 한다. 툴킷이나 라이브러리가 시스템의 직교성을 해치지는 않는지 확인 필요.

**코딩:**

> 코딩시 직교성 유지하는 법

- 코드의 결합도 줄이기
  - 부끄럼쟁이 코드 작성하기.
    - 불필요한 것은 다른 모듈에 보여주지 X.
    - 다른 모듈에 의존하지 않는 코드 작성하기.
- 전역 데이터 피하기
  - 전역 데이터를 참조한다는 것은 해당 데이터를 공유하는 다른 컴포넌트와 묶인다는 것.
  - 싱글턴 사용도 주의. 불필요한 결합을 만들 수 있음.
- 유사한 함수 피하기.
  - 중복된 코드는 문제가 있다는 증거.

Refactoring: 자신이 작성하는 코드를 항상 비판적으로 바라보고 코드의 구조와 직교성을 위해 노력할 것.

</details>

<details><summary>도메인 언어</summary>

> Domain Languages 领域语言

도메인 언어: 특정 도메인의 문제 영역에 특화된 프로그래밍 언어.

`언어의 한계가 곧 자기 세계의 한계다. -Ludwig Wittgenstein`

- 컴퓨터 언어는 문제 및 의사소통에 대해 생각하는 방식에 영향을 미친다.
  - Static Typed, Dynamic Typed
  - Early Binding, Late Binding
  - Functional, Object-Oriented
- 문제 도메인에 가깝게 프로그래밍 하라.

- 도메인과 언어:
  - 데이터베이스: SQL
  - 통계, 분석: R
  - 수치 계산, 과학적 컴퓨팅: MATLAB
  - 논리 프로그래밍: Prolog
    - 공학, 수학, 데이터 분석 etc
  - 웹: JavaScript
  - iOS, macOS: Switft

</details>

<details><summary>추정</summary>

> Estimating 估算

추정하는 법 배우기, 추정 능력 개발하기.

### 얼마나 정확해야 충분히 정확한가?

> 추정의 답변의 단위는 아래 처럼

| 기간       | 추정의 단위       |
| ---------- | ----------------- |
| 1-15 일    | 일                |
| 3-6 주     | 주                |
| 8-20 주    | 달                |
| 20 주 이상 | 다시 생각해 볼 것 |

### 추정치는 어디에서 나오는가?

추정 비법:

- 관련 일을 해본적 있는 사람에게 물어보기.

- 무엇을 묻고 있는지 이해하라

  - 상대가 무엇을 묻고 있는가?
  - 도메인에 존재하는 조건(scope)에 대해 알기.

- 시스템의 모델을 만들어라

  - 시스템을 어떻게 구현하느냐에 관한 밑그림.
  - 해당 과정에서 미처 몰랐던 패턴이나 프로세스를 발견할 수도 있음.

- 모델을 컴포넌트로 나눠라

  - 컴포넌트로 분해.
  - 컴포넌트들의 상호작용을 수식으로 기술.

- 각 매개 변수에 값을 할당하라

  - 컴포넌트의 매개변수.
  - 매개변수의 값을 최대한 정확히 산출해 내기.

- 답을 계산하라

  - 주요 매개 변수들의 값을 바꾸어가며 계산해보기.

- 여러분의 추정 실력을 기록하라

  - 계산했던 추정치를 기록해놓고 나중에 비교해보자. 추정 값이 실제 결과와 얼마나 비슷했는가?
    - 오차 범위가 큰 경우: 왜? 무엇때문에 범위가 이렇게 벌어지게 되었을까?

### 프로젝트 일정 추정하기

> 불확실성을 줄이는 방법 알아보기.

- 프로그램 평가 검토 기법(Program Evaluation Review Technique)

  - 낙관적 추정치(Optimistic Estimate):
    - 가장 이상적 조건에서 소요되는 최소 시간으로 예상되는 값.
  - 비관적 추정치(Pessimistic Estimate):
    - 예상대로 진행되지 않을 경우 소요되는 최대 시간으로 예상되는 값.
  - 기대값(Expected Value):
    - 낙관적 추정치와 비관적 추정치 사의의 중간 값.

- 요구사항 확인하기.
- 위험을 분석하고 위험도가 높은 부분을 우선 하기.
- 설계, 구현, 통합.
- 사용자와 함께 검증하기.

어찌되었건 해본적이 없는 프로젝트라면 어림짐작 일정이기 마기.

- 초기 기능 구현, 테스트 이후 이를 첫번째 반복 주기로 삼을것. → 반복 및 조정

</details>

---

# 3

## 기본 도구

> The Basic Tools 基础工具

<details><summary>셸 가지고 놀기</summary>

> Shell Games Shell 游戏

목수의 작업대처럼 프로그래머의 작업대는 shell 이다.

- `GUI의 환경의 기능은 일반적으로 설계자가 의도한 범위를 넘어설 수 없다.`

  - GUI 장점: WYSIWYG (What You See Is What You Get)
  - GUI 단점: WYSIAYG (What You See Is All You Get)

- Shell 에 익숙해지면 생산성도 상승한다.
  - 자동화와 스크립팅
  - 강력한 명령어
    - 복잡한 작업을 단일 명령어로
  - 리소스 효율성
    - 텍스트 기반
  - 빠른 작업 흐름

</details>

<details><summary>파워 에디팅</summary>

> Power Editing 加强编辑能力

여러개의 에디터를 사용해도 상관이 없지만 사용법에 익숙해야 한다.

`에디터를 유창하게 쓸 수 있게 하라`:

- 의식하지 않고 사용 할 수 있도록.
- 명령어 배우기.
- 확장 기능 찾아보기.

</details>

<details><summary>디버깅</summary>

> Debugging 调试

### 디버깅의 심리

- 공략 마음가짐: 디버깅 == 문제 풀이
- 타인의 버그 발견 후 비난하는 것이 아닌 문제를 고치는데 주력할 것.

### 디버깅 사고방식

- 가장 속이기 쉬운 사람은 자기 자신이다. (Edward Bulwer-Lytton)
  - 근시안 벗어나기:
    - 한 발짝 물러나 버그라고 생각하는 증상의 원인이 무엇인지 생각할 것.
    - 실제 문제는 표면에 보이지 않을 수 있다는 것을 염두에 둘 것.
    - 문제의 근본 원인을 찾고자 할 것.

### 실마리 찾기

- 빌드부터:
  - 디버깅 전 문제 없이 빌드되는 지 확인할 것.
  - 컴파일러 경고 수준 제일 높게 맞추기.
    - 컴퓨터가 대신 찾아 줄 수 있는 문제를 찾아줌으로써 시간 낭비를 줄여주기 때문.
- 관련 자료 모으기:
  - 버그를 보고한자로부터 받은 자료가 불확실/불충분할 경우 필요한 자료 재요구 할 것.
- 경계조건과 최종 사용자의 사용 패턴 모두 테스트 할 것.

### 디버깅 전략

- 버그 재현하기:
  - 제일 좋기로는 `명령어 하나` 로 재현 할 수 있도록 하기.
    - 버그 재현을 위한 단계를 최대한 줄이는 것이 좋다.
- 실패하는 테스트 작성:
  - 실패하는 상황과 그렇지 않은 상황을 분리하는 것은 통찰력을 선사함.
- 오류 메시지 제발 읽을것!
- 이러한 상황엔 이렇게:

  - 이상한 결과:
    - 디버거를 붙여 실패하는 테스트를 이용하여 문제를 재현하며 풀어가기.
    - 디버거에 잘못된 값이 존재하는가?
    - 디버거에서 `호출 스택 이동` 및 `스택의 지역변수 확인하는 법`에 관해 숙달해 놓기.
    - 메모하며 풀기.
      - 추적용: 시간 낭비를 줄여줌.
  - 입력값에 따라 바뀔 때:
    - 이진분할 사용:
      - 스택 프레임을 하나하나 보는 것 보다 더 빠른 방법일 수 있음.
  - 릴리즈 사이에 발생한 문제:
    - 이진분할 사용하기.
      - 분할 정복(divide and conquer)

- 그외의 방법:

  - 로깅과 트레이싱
    - 로깅 메시지는 규칙적이고 일관되게 작성 할 것.
      - 메시지 자동 분석에 도움이 됨.
  - 고무 오리
  - 소거법

- 가정하지 말고 증명할 것.

  - 버그를 고치는데서 끝나서는 안된다.
    - 자문하기:
      - 왜 이 문제가 더 일찍 발견되지 않았을까?
      - 해당 버그를 수정하는데 왜 오랜시간이 걸렸을까?
      - 비슷한 버그가 존재하지 않을까?
      - 다음번에는 어떻게 더 쉽게 고칠 수 있지?
    - 테스트 작성하기.
    - 토론하기:
      - 누군가의 잘못된 가정으로 발생한 버그라면 팀과 함께 토론하기. (다른 팀원들도 동일한 실수를 방지시키기 위해)

- 디버깅 체크리스트 작성하기.

</details>

<details><summary>엔지니어링 일지</summary>
> Engineering Daybooks 工程日记

- 일지가 주는 장점:
  - 기억보단 기록이 더 믿을만함.
  - 진행중인 작업과 직접적인 관계가 없는 발상을 쌓아 둘 수 있음.
    - 진행중인 일 먼저 작업 이후에 잊지 않고 처리하는데 도움됨.
  - 고무 오리와 같은 역할.
    - 작업하던 일을 돌아 볼 수 있게 해줌.
  - 과거의 내가 어떤 일을 했는지 알 수 있게 해줌.

</details>

---

# 4

## 실용주의 편집증

> Pragmatic Paranoia 务实的偏执

완벽한 소프트웨어는 만들 수 없다.

방어운전을 하듯 방어적으로 코딩을 해야한다. 하지만 이로써는 부족하다. 실용주의 프로그래머는 자기 자신 역시 믿지 않아야한다. 이는 자신의 실수에 대비하여 방어책을 만들어 놓는것을 의미한다.

<details><summary>계약에 의한 설계</summary>

> Design by Contract 契约式设计

정직한 거래 보장하는 법: 계약

### DBC

> Design By Contract 계약에 의한 설계

- 프로그램의 정확성을 확보.

  - 정확성: 자신이 하는 일이라고 주장하는 것보다 많지도 적지도 않게 딱 그만큼만 하는 프로그램.

- 선행조건(Precondition)

  - 메서드/함수가 호출되기 전에 만족해야하는 조건.
  - 조건 위반시 호출되지 않아야 함.
  - 호출자:
    - 제대로 된 데이터 전달하기.
    - 호출 순서, 상태에 대한 요구사항 명시.

- 후행조건(Postcondition)

  - 루틴이 끝난 후에 보장되어야 하는 조건.
  - 무한반복은 허용되지 않음.
  - 함수/메서드 반환값이나 상태 변경과 관련된 요구사항 명시.

- 클래스 불변식(Class Invariant)

  - 클래스의 객체가 생성되고 유지되는 동안 만족해야하는 조건.
  - 객체의 상태와 관련된 불변적 특성을 명시.
    - 객체의 특정 속성은 항상 유지되어야 한다.

- DBC를 잘 지원하는 언어: Clojure

  - Clojure 언어의 특성
    - Assert 매크로
      - assert 매크로를 통해 사전조건, 사후조건을 검사.
    - Spec 시스템
      - 데이터의 구조와 유효성 검사.
    - Immutable 데이터
      - 불변성을 가진 데이터 구조를 강조. 클래스 불변식을 유지할 수 있도록 도움.
    - REPL 환경

- 게으름뱅이 코드: `시작하기 전에 자신이 수용할 것은 엄격하게 확인하고, 내어 줄 것에 대해서는 최소한도를 약속하는 것.`

- DBC Vs. TDD

  > DBC 와 TDD 모두 가치있는 방법론이다.

  |                  | DBC                                               | TDD                                             |
  | ---------------- | ------------------------------------------------- | ----------------------------------------------- |
  | Concept          | 컴포넌트 간의 계약을 기반                         | 테스트를 중심으로 개발                          |
  | Goal             | 소프트웨어의 정확성과 신뢰성 확보                 | 버그를 줄이고 안정적인 소프트웨어 개발          |
  | Focus            | 사전조건, 사후조건, 클래스 불변식에 초점          | 테스트 케이스 작성 및 검증 중심                 |
  | Testing          | 컴포넌트의 사전조건과 사후조건 검증을 중심으로 함 | 테스트 케이스 작성 및 검증을 중심으로 함        |
  | Purpose          | 코드의 정확성과 신뢰성을 확보하기 위함            | 코드의 품질을 향상시키고 버그를 최소화하기 위함 |
  | Execution Timing | 설계 단계에서 계약 명시 및 검증                   | 개발 단계에서 테스트 케이스 작성 및 검증을 진행 |
  | Advantages       | 정확성과 신뢰성을 높일 수 있음                    | 코드 품질 향상 및 초기 버그 발견 가능           |
  | Disadvantages    | 컨트랙트 작성 및 유지에 추가적인 비용 발생        | 테스트 케이스 작성에 추가적인 시간과 노력 필요  |

- DBC 구현

  - 코드 작성전 생각하기:

    - 유효한 입력 범위는?
    - 경계 조건(Boundary Condition)은?
      - 입력, 출력, 동작 범위의 끝 부분에 해당하는 조건
    - 루틴은 무엇을 전달할까?

  - 단정문:
    - 프로그램의 특정 지점에서 조건을 검증. 해당 조건이 True 인지 확인.
    - 이를 통해 코드의 정확성을 검증, 예회 상황 식별.

- DBC와 일찍 멈추기

  - `문제를 찾고 원인을 밝히기 위해서는 사고가 난 지점에서 일찍 멈추는 것이 유리하다.`
    - 문제가 발생한 지점에서 바로 멈추어 추가 연산을 중단시킴.
    - 멈춘 부분에서부터 오류 분석, 원인 파악. 즉 조기에 발견하여 신속하게 대응하기 위함.

- 의미론적 불변식
  - 의미론적:
    - 조건이 프로그램의 의미 또는 의도에 부합하는지?
  - 불변식:
    - 프로그램의 실행 중에 변하지 않아야 하는 조건
  - 명확하고 모호한 점이 없도록 서술.

</details>

<details><summary>단정적 프로그래밍</summary>

> Assertive Programming 断言式编程

`그런 일은 절대 일어날 리 없어` 라는 생각 버리기. 제일 간단하기로는 단정문 사용하기.

- 오류처리가 되야 하는 부분에서는 단정문을 사용하지 않기.
- 결코 일어나면 안되는 것들의 경우 단정문을 사용할 것.
  - 코드가 예상대로 동작하는지 확인하기 위한 목적으로 사용.

</details>

---

# 5

## 구부러지거나 부러지거나

> Bend, or Break 宁弯不折

<details><summary>결합도 줄이기</summary>

> Decoupling 解耦

- 높은 결합도는 변경의 적.
  - 결합도가 높을 수록 변경해야하는 것들도 증가.
  - 소프트웨어는 다리(bridge) 와 반대로 설계를 해야한다. 즉, 단단한 구조가 아닌 언제든 형태를 유연하게 바꿀 수 있도록.

하지만 결합은 두 개의 코드 조각이 무언가를 공유할 시 일어날 수 밖에 없다.

### 열차 사고(train wreck)

> 메소드 호출이 열차의 모습처럼 연쇄적으로 이어져 있는 모습을 생각해보라.

```java
public void applyDiscount(customer, order_id, discount) {
  totals = customer
           .order
           .find(order_id)
           .getTotals();
  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```

- 메서드의 속성들이 모두 연결되어 있는 상태.

열차 사고 개선법: 묻지 말고 말하라(Tell, Don't Ask)

- e.g. `.order.find(order_id)` 주문 컬렉셕을 가져와 주문을 찾으면 안됨. 고객 객체에서 바로 주문 객체를 가져와야 함.
- 묻는것:

  - 다른 객체에게 정보 요청하기.
  - 다른 객체에게 상태 물어보기.
  - 객체 간의 의존성 생성, 객체가 다른 객체의 내부 상태에 접근해야 한다.
    - 캡슐화와 정보 은닉 원칙을 위반하는 꼴.

- 말하는 것:

  - 다른 객체에게 명령을 내리는 것.
    - 객체간의 느슨한 결합.
    - 정보 은닉.

- 데메테르 법칙(Law of Demeter)
  - 객체는 자신이 직접 알고 있는 객체에게만 메서드 호출을 해야 함.
    - 객체는 자신이 갖고 있는 메서드만 호출.
    - 객체는 다른 객체의 상태를 직접 할거나 접근해서는 안됨.
    - 객체는 다른 객체의 내부 구조를 알거나 다른 객체의 내부 메서드를 호출해서는 안됨.
  - 메서드 호출을 엮지 말라.
    - 무언가에 접근시 "." 연산자를 하나만 쓰도록 노력할 것.
      - 예외: 엮는 것들이 절대로 바뀌지 않을 것이라면 이 규칙을 지키지 않아도 됨.

### 글로벌화의 해악

어디서나 접근할 수 있는 데이터: 컴포넌트 간의 결합을 만들어 냄.

`전역 데이터를 피하라`:

- 모든 메서드안에서 사용할 수 있는 전역데이터는 모든 메서드에 매개 변수가 추가된 것과 같은 효과를 만든다.
  - 글로벌 데이터의 변경이 의도치 않은 영향을 줄 수 있다.
  - 글로벌 데이터에 대핸 의존성으로 테스트/디버깅이 어렵게 된다.

싱글턴도 전역데이터:

- 외부로 노출된 인스턴스 변수가 있는 싱글턴 또한 전역데이터.

외부 리소스도 전역 데이터:

- 수정 가능한 외부 리소스

### 결국은 모두 ETC

- 결합을 낮추어 바꾸기 쉬운 코드로 만들어야 한다. 하나를 바꿈으로 다른 곳에 영향이 끼치지 않도록.

</details>

<details><summary>설정</summary>

> Configuration 配置

변화할 값에 코드를 의존시키도록 하지 말것. 변화하는 값은 App 외부에서 관리시키자.

- App을 변경하지 않고서도 설정을 조정 할 수 있게 해줌.
- 수월한 유지보수/업데이트
- 환경별 최적화
  - 개발, 테스트, 운영 등.

설정 데이터:

- 인증 정보
- 로그 레벨, 로그 저장 위치
- 포트 번호, IP 주소, 기계/클러스터명
- 라이선스 키

### 정적 설정

`정적 설정`: 설정을 자료구조 형태로 불러오는 형태. APP 시작 시점에 설정 값을 읽어와 이를 전역으로 접근할 수 있도록 한다.

- 설정을 전역에서 접근할 수 있도록 하지 않도록 할 것.
- 설정 정보를 API 뒤로 숨기기.
  - 설정을 담당하는 모듈/클래스를 통해 값을 제공하도록.
  - 결합도를 낮춰준다. 코드가 설정에 직접 의존하지 않도록 해줌.

## 서비스형 설정

장점:

- 여러 App이 설정 정보를 공유 할 수 있음.
- 여러 인스턴스에 걸쳐 전체 설정을 한번에 바꿀 수 있음.
- 설정 데이터를 전용 UI로 관리할 수 있음.
- 설정 데이터를 동적으로 바꿀 수 있음.
  - 고가용성 App

</details>

---

# 6

## 동시성

> Concurrency 并发

- 동시성(concurrency): 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것.
- 병렬성(parallelism): 실제로 동시에 실행되는 것.

### 모든 일에 동시성이 있다

세상은 비동기적, 프로그램이 세상을 다루기 위해서는 동시성은 필수
여태 책에서 이야기 하였던 코드의 결합처럼 시간적 결합(temporal coupling)도 조심해야한다.

- 시간적 결합: 둘 이상의 작업이 실행되는 시간이나 순서에 서로 의존하는 상태.

동시성이 어려운 이유:

- 공유 상태(Shared state)
  - 데이터 무결성을 유지하기가 힘듬.
  - 해결책: 액터 모델
    - 프로세서들이 독짋적으로 수행된다.
    - 서로간에 데이터를 공유 X

<details><summary>시간적 결합 깨트리기</summary>

직선적 사고 방식이 시간적 결합을 만든다.

- A를 완료한 후에 B를 하고...똑.딱.똑.딱.똑-다음은-딱.

신경써야 할 시간의 두 가지 측면

- 동시성
- 순서

### 동시성 찾기

- 활동 다이어그램(activity diagram)을 통해 작업흐름을 모델화하고 분석할 수 있다.
  - 찾아내기: 동시에 수행할수 있는 작업이지만 현재 그렇지 않는 것들은?
    - 찾아낸 부분을 어떻게 안전하게 구현할 수 있을까?

### 병렬 작업의 기회

- 엘릭서의 컴파일러
  - 커다란 작업을 쪼개서 병렬로 처리 → 결과 합치기

</details>

<details><summary>공유 상태는 틀린 상태</summary>

상태를 공유해서는 안된다. 비원자적 갱신을 원자적으로 바꾸어야 한다.

- 비원자적 갱신(Non-Atomic Update)
  - 여러 단계로 이뤄진 갱신 작업.
  - 다수의 명령이 수행될 때 중간에 다른 작업이 들어옴으로 인해 갱신 작업이 중단될 위험성 존재.
- 원자적 갱신(Atomic Update)
  - 동시성 문제 방지.

`불규칙한 실패는 동시성 문제인 경우가 많다.`

</details>

<details><summary>액터와 프로세스</summary>

### 액터는 언제나 동시성을 띤다

- 액터는 아무것도 공유하지 않으며 비동기적으로 동시에 실행된다.
  - 액터 자신의 상태를 공유하지 않는다.
  - 서로의 상태에 영향을 주지 않으며 비동기적으로 상호작용한다.
    - 메시지 전송하는 측과 메시지 수신하는 측의 동작이 병렬적으로 진행됨. 기다리지 않음.

`공유 상태 없는 동시성을 위하여 액터를 사용하라.`

</details>

---

# 7

## 코딩하는 동안

> While You Are Coding 当你编码时

코딩할 때 기계적으로 코딩해서는 안된다. 자신이 만든 코드가 왜 작동하는지 모른다는 것은 생각하지 않고 코딩했다는 것.

테스트는 버그를 찾는 것이 아닌 자신의 코드에 피드백을 주는 작업.

<details><summary>파충류의 뇌에 귀 기울이기</summary>

- Lizard Brain: 감정과 생존

즉, 본능(무의식)에 귀기울일줄도 알아야한다.

- 코드와 떨어져 다른 행동을 하다보면 무의식중에 떠오르는 eureka moment
- 또는 고무오리에게 설명하기

다른 사람의 코드를 읽으면서 중요하게 생각되는 부분, 처리 방식이 이상해보이는 부분들을 기록해 놓기.

- 패턴 찾기
- 작성자가 그렇게 코딩할 수 밖에 없었던 이유를 찾아 낼 수 있다. 이는 코드 이해도를 높혀준다.

</details>

<details><summary>우연에 맡기는 프로그래밍</summary>

- 우연이 아닌 의도적 프로그래밍을 하자.
  - 지금 무엇을 하고 있는지 알아야 한다.
  - 더 경험이 적은 프로그래머에게 이해할 수 없게 설명한다면 잘 알지 못하는 것.
  - 자신도 잘 모르는 코드를 작성하지 말것.
  - 계획을 세우고 그것을 바탕으로 진행할 것.
  - 노력을 들일 우선순위를 정하는 것도 중요.
    - 보통 어려운 부분이 중요한 부분이기도 하다.
- 근거없는 확신을 하지 말자.
  - 가정하지 말고, 증명하라!
  - 확실하지 않은데 의존하고 있는 것이 있나?
    - 이는 재앙의 근원이 된다.
  - 신뢰할 수 있는 것에만 의존하라.
  - 가정을 기록으로 남길 것.
    - 코드를 테스트하는 것 처럼 세운 가정도 테스트해보아야 한다.
- 모듈화를 잘 할것.

작성한 코드가 잘 돌아가는듯 하지만 우연으로 인한것이 아닐까?

- 유령 패턴
- 상황에서 생기는 우연
- 암묵적인 가정

</details>

<details><summary>리팩터링</summary>

- 리팩토링은 체계적으로 해야한다.
  - 무질서하게 대규모로 갈아 엎어서는 X
- 리팩터링은 기능을 추가하는 작업이 아니다.
  - 리팩터링 후 기존 기능이 잘 돌아가는지 확인해야 한다. 이를 위해 테스트 코드 완비.
  - 리팩터링의 본질은 재설계.
- '괜히 작동하는 코드를 긁어 부스럼 만든다' 라고 생각해서는 안된다.

### 리팩터링은 언제 하는가?

- 무언가를 알게 되었을 때 진행:
  - 무언가 잘못되었다 라는 생각이 들 때.
  - 과거보다 아는게 더 많아졌을 때.
- 핑계대지 말자: 일정의 압박으로 인해 리팩터링할 시간이 없어요...
  - 일정에 리팩터링할 시간도 포함시킬 것.
- 종양(리팩터링할 코드)이 커지기 작업하라.
  - 시간을 끌 수록 위험도도 같이 증가한다.

`일찍 리팩터링하고, 자주 리팩터링하라.`

### 리팩터링은 어떻게 하는가?

- 리팩터링과 기능 추가를 동시에 하지 말라.
- 테스트는 리팩터링 전에 구비되어 있어야한다.
  - 테스트 코드는 리팩터링을 하면서 무언가가 망가지게 됬는지 알려준다.
- 단계를 나누어 작업하라.
  - 단계 단계마다 테스트 돌리기.

</details>

<details><summary>바깥에서는 안전에 주의하라</summary>

- 바깥 세상 의심하기.
  - 시스템을 공격하려는 외부 시도.
  - 내부 오류 뿐만 아니라 외부 오류 고려하여 테스트 코드 짜기.

### 기본 보안 법칙

건전한 편집증 갖기.

- 공격 표면 최소화.
  - 표면: 모든 접근 지점을 말함.
    - 데이터 입력하는 부분.
      - 공격 매개체가 됨.
      - 외부에서 입력되는 값이 Invalid 한 경우 다음 루틴에 전달 전에 제거.
    - 데이터를 추출하는 부분.
      - 정보를 누설하지 말것.
      - 디버깅 정보가 공격 매개체가 됨.
    - 서비스를 실행하는 부분.
  - 단순한 코드 만들기.
    - 복잡한 코드일수록 보안 헛점이 크다.
- 최소 권한 원칙.
  - 인증 받은 사용자 수를 최소로 유지.
    - 더 이상 유효하지 않은 또는 사용되지 않는 사용자/서비스 정리.
  - 최소한의 권한을 필요한 시간만큼이지만 짧게 부여.
  - 높은 권한은 최소한의 일만 수행후 권한 파기.
  - 권한은 적을수록 좋다.
- 안전한 기본값.
- 민간 정보 암호화.
- 보안 업데이트 적용.
  - 보안 패치 신속히 적용하기.

비밀번호:

- 길이를 64자 이하로 제한 X.
- 출력 가능한 ASCII 문자, 공백, 유니코드 문자 모두 허용.
- 특별한 조합 규칙 X.
  - 대문자 + 소문자 + 특수문자
- 일정기간이 흐름으로 인한 비밀번호 변경 요청 X.
  - 합당한 이유가 있을 경우에만 변경 요구: 데이터 유출 등.

</details>
