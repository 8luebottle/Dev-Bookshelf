# Clean Code
Clean Code : A Handbook of Agile Software Craftmanship  

### Highfive Tech Book Club
하이파이브 기술 독서 모임 (매주 월요일 19:30 PM)

## Table of Contents

|Chapter|       Title      | Page  |   Date   |
|-------|:----------------:|:-----:|:--------:|
|01     |깨끗한 코드          |001-020|07.27.2020|
|02     |의미 있는 이름       |021-038|08.03.2020|
|03     |함수               |039-065|08.10.2020|
|04     |주석               |067-094|08.24.2020|
|05     |형식 맞추기          |095-114|08.31.2020|
|06     |객체와 자료 구조      |117-128|09.07.2020|
|07     |오류 처리           |129-142|09.14.2020|
|08     |경계               |143-152|09.21.2020|
|09     |단위 테스트          |153-170|09.28.2020|
|10     |클래스             |171-192|10.05.2020|
|11     |시스템             |193-214|10.12.2020|
|[12](#12)|창발성             |215-224|10.19.2020|
|[13](#13)|동시성             |225-244|10.26.2020|
|14     |점진적인 개선        |245-322|11.02.2020|
|15     |JUnite 들여다보기   |323-342|---Skip---|
|16     |SerialDate 리팩터링 |343-365|---Skip---|
|[17](#17)|냄새와 휴리스틱      |367-406|11.09.2020|
---

# 12
## 창발성
> Emergence

### **단순한 설계규칙**

중요한 순서대로 나열한 다음의 네가지 규칙을 따른다면 우수한 설계를 구현시킨 코드를 작성할 수 있다.

**Kent Beck’s 4 Rules of Simple Design** 

1. **모든 테스트를 실행한다.**
2. **중복을 없앤다.**  
    리팩터링을 통한 중복 없애기

3. **프로그래머 의도를 표현한다.**
4. **클래스와 메서드 수를 최소로 줄인다.**

<details><summary>모든 테스트를 실행하라</summary>  

테스트를 통해 얻고자 하는 것은 무엇인가 ?  
  - 만들어 놓은 시스템이 설계도 처럼 잘 작동하는지 검증하기 위한 도구로 쓰기 위함.

테스트 가능한 시스템을 제작해나가는 과정에서 좋은 품질은 저절로 따라온다.  
그 이유는 좋은 품질과 직결되는 아래의 규칙을 준수 해야만 쉽게 테스트 케이스를 작성할수 있기 때문이다.

- 하나의 목적만 수행하는 작은 Class
- SRP 를 준수  
    SRP : Single Responsibility Principle | 단일 책임 원칙

- DIP 를 준수  
    DIP : Dependency Inversion Principle | 의존 관계 역전 원칙

    결합도를 낮추어야 테스트 케이스 작성이 쉽다.

테스트 케이스를 작성함으로써 일거양득(낮은 결합도, 높은 응집력)의 혜택을 얻게된다.

</details>

<details><summary>리팩터링</summary>  

코드를 점진적으로 리팩터링하자.  

중간 중간 코드가 몇줄이라도 추가되는 경우, 잠시 시간을 들여 설계를 조감해 보는 노력이 필요하다.

- 새로 추가한 코드가 설계 품질을 낮추었는가?

    if true

    ⇒ 해당 코드를 깔끔히 정리

    ⇒ 테스트 케이스 돌려 기존 기능이 깨졌는지 확인

이 단계에서 설계 품질을 높일수 있는 기법이 있다면 그것이 무엇이든 적용해도 괜찮다.

- 응집도 높이기
- 결합도 낮추기
- 관심사 분리하기
- 시스템 관심사를 모듈로 나누기
- 함수 및 클래스 크기 줄이기
- 더 나은 이름 선택하기
- 중복 없애기

</details>

<details><summary>표현하라</summary>  

유지보수를 위해 '개발자의 의도'를 분명히 표현할 줄 알아야 한다.

어찌되었든 '유지보수를 하는 개발자' 가 '코드를 작성한 개발자' 보다 코드를 깊이 이해할 가능성은 희박하다. 그렇기에 '코드를 작성하는 개발자'는 개발자는 코드별 의도가 무엇인지 명백히 들어나도록 짜야한다. 이는 결함과 유지보수 비용을 줄여준다.

아래의 법칙을 따르자.

1. **좋은 이름 선택하기**
2. **함수와 클래스 크기 가능한 줄이기**
3. **표준 명칭 사용하기**
4. **단위 테스트 케이스 작성하기**  
   테스트 케이스는 '예제로 보여주는 문서'라 할 수 있다. 이를 읽다보면 클래스 기능이 한 눈에 들어오게 된다.

</details>

<details><summary>클래스와 메서드 수를 최소로 줄여라</summary>  

클래스와 메서드 수를 줄이는 방법은 **중복을 제거**, **의도를 표현**, **SRP를 준수** 하는 것이다.

하지만 이 규칙(네가지 규칙중 우선순위가 가장 낮은)은 부득이한 상황이라면 넘어가도 좋다.  
대신 코드의 중복을 확실히 제거하고 코드의 의도를 잘 표현하도록 하자.

</details>

# 13
## 동시성
> Concurrency

<details><summary>동시성 관련 기본 용어</summary>  

- **한정된 자원 Bound Resource**  
   다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.  
   - 예) 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등.

- **상호 배제 Mutual Exclusion**  
   한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우.

- **기아 Starvation**  
   한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.  
   - 예) 항상 짧은 스레드에게 우선순위를 준다면, 긴 스레드가 기아 상태에 빠진다.

- **데드락 Deadlock**  
   여러 스레드가 서로 끝나기를 기다린다.  
   모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.

- **라이브락 Livelock**  
   락을 거는 단계에서 각 스레드가 서로를 방해한다.  
   스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

</details>

<details><summary>동시성이 필요한 이유</summary>  

결합(`coupling`)을 없애기 위해서 → 무엇(`what`)과 언제(`when`)를 분리하는 전략 세우기.  
   - 이를 잘 분리한다면 앱 구조와 효율이 극적으로 나아진다.

단일 스레드인 프로그램은 무엇과 언제가 밀접하게 연관되어 있다.  
그렇기에 Call stack 을 보면 프로그램 구동 상태를 쉽게 알 수 있다.

<img width="500" alt="Call stack" src="https://user-images.githubusercontent.com/48475824/130341758-e92b29d6-99c3-4260-83f6-695ed58934e1.png">

Image Credits : JS Conference

**단일 스레드 Debugging 방법**  
- Breakpoint 찍어 정지점 확인하기.

**Structural point of view**
프로그램은 거대한 루프 하나가 아니다. 작은 협력 프로그램 여럿으로 나누어져 있다.  
시스템을 이해하기가 쉽고 분리 하기도 쉽다.

**동시성의 예 : JAVA's Servlet Model**  
- 서블릿은 웹 혹은 EJB Container 라는 우산 아래서 돌아간다.
   
- 컨테이너는 동시성을 부분적으로 관리한다.
   
- 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다.
   
- 서블릿 프로그래머는 들어오는 모든 웹 요청을 관리할 필요가 없다.
   
- 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
    <img width="338" alt="Servlet Concurrency" src="https://user-images.githubusercontent.com/48475824/130341778-05b37984-529d-4a6a-8a82-c7086a2204cc.png">

    Image Credits : [Servlet Concurrency](http://tutorials.jenkov.com/java-servlets/servlet-concurrency.html)

</details>

<details><summary>동시성에 관한 미신과 오해</summary>  

1. **동시성은 항상 성능을 높여준다?**  
  동시성은 때로 성능을 높여준다. 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다. 어느 쪽도 일상적으로 발생하는 상황은 아니다.

1. **동시성을 구현해도 설계는 변하지 않는다?**  
  단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.  
  일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.

1. **웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다?**  
  실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야 한다.

</details>

<details><summary>동시성 관련 타당한 생각</summary>  

1. **동시성은 다소 부하를 유발한다.**  
  성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.

1. **동시성은 복잡하다.**  
  간단한 문제라도 동시성은 복잡하다.

1. **일반적으로 동시성 버그는 재현하기 어렵다.**  
  진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.

1. **동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.**

</details>

<details><summary>동시성 방어 원칙</summary>  

- **단일 책임 원칙 Single Responsibility Principle**  
  `solution`: 다른 코드와 분리할 것.

  SRP : 주어진 메서드/클래스/컴포넌트를 변경할 이유는 오직 하나.  
    - 동시성 관련 코드는 다른 코드와 분리할 것.  
        👷🏻‍♀️ 주의 👷🏻‍♀️  동시성과 관련이 없는 코드에 동시성을 곧바로 구현하는 실수를 범하지 말자
    - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.

- **자료 범위를 제한하라**  
  `solution`: 자료를 캡슐화 할 것. 공유 자료를 최대한 줄일 것.

  공유 자료를 줄이지 않는다면 여러 스레드가 서로 간섭하므로 예상치 못한 결과가 발생하게 된다.

  해결책 → 공유 객체를 사용하는 코드 내 임계영역(critical section)을 Synchronized 키워드로 보호

  **[공유 자료를 수정하는 위치가 많을수록 발생하는 문제점들]**
  - 보호할 임계영역을 빼먹는다. ⇒ 공유 자료를 수정하는 모든 코드가 망가짐.

  - 모든 임계영역을 올바로 보호했는지(DRY 위반) 확인하느라 똑같은 노력과 수고를 반복한다.

  - 버그를 찾기가 더 어려워짐.

- **자료 사본을 사용하라**  
  공유 객체를 피하게 될수록 코드가 문제를 일으킬 가능성도 아주 낮아지게 된다.

  공유 자료를 줄이려면 제일 좋기로는 처음부터 공유하지 말아야 한다.
   
  - 읽기 전용으로 사용하기
   
  - 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오기. 
    객체를 복사하는 시간과 부하가 걱정스러울 수도 있다. 그렇다면 복사 비용이 진짜 문제인지 실측해볼 필요가 있다.

  사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

- **스레드는 가능한 독립적으로 구현하라**  
   `solution`: 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할할것.

   - 자신만의 세상에 존재하는 스레드를 구현.
     - 다른 스레드와 자료를 공유하지 말것.  
      각 스레드는 클라이언트 요청 하나를 처리하도록 만든다.

      - 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장.  
        서블릿 코드가 로컬 변수만 사용한다면 서블릿이 동기화 문제를 일으킬 가능성은 전무하다.
  
</details>

<details><summary>실행 모델을 이해하라</summary>  

**생산자-소비자 Producer-Consumer**  
- 하나 이상 생산자 스레드가 정보를 생성해 버퍼buffer나 대기열queue에 넣는다.
   
- 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
   
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
  - 생산자 스레드 → 대기열에 빈 공간이 있으면 정보를 채움
    - 빈 공간이 생길 때까지 기다림
    - 대기열에 정보를 채운 후 소비자 스레드에게 “대기열에 정보가 있다" 시그널을 보냄

  - 소비자 스레드 → 대기열에 정보가 있어야 가져옴
     - 정보가 채워질 때까지 기다림
     - 대기열에서 정보를 읽어들인 후 “대기열에 빈 공간이 있다" 시그널을 보냄

   대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다.  
   잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

**읽기-쓰기 Readers-Writers**  
읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하고 쓰기 스레드가 이 공유 자원을 이따금 갱신하는 경우 발생하는 문제는 throughput(처리율) 이다.

- 처리율을 강조하면 기아(starvation) 현상이 생기거나 오래된 정보가 쌓인다.
  - 갱신을 허용하면 처리율에 영향을 미친다.
  - 복잡한 균형잡기가 필요다. 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.
  
- 읽기 스레드 요구와 쓰기 스레드 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다.
  - 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리게 하기.
    - 하지만 읽기 스레드가 계속 이어진다면 쓰기 스레드는 기아 상태에 빠진다.반면, 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 계속 이어진다면 처리율이 떨어진다.
    - 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다.

**식사하는 철학자들 Dining Philosophers**  
   
<img width="338" alt="Dining Philosophers" src="https://user-images.githubusercontent.com/48475824/130341804-88dbab25-248f-4b34-b726-3ebfdae98c96.png">

Image Credits : [Dining Philosophers](https://sphof.readthedocs.io/test2.html)

</details>

<details><summary>동기화하는 메서드 사이에 존재하는 의존성을 이해하라</summary>  
   
동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.  
권장사항 : 공유 객체 하나당 메서드 하나

만약 **공유 객체 하나에 여러 메서드**가 필요한 상황이라면 아래 방법을 이용할 수 있다.  
1. **클라이언트에서 잠금**  
  클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다.  
  마지막 메서드를 호출할 때까지 잠금을 유지한다.

1. **서버에서 잠금**  
  서버에다 “서버를 잠그고 모든 메서드를 호출할 후 잠금을 해제하는" 메서드를 구현한다.  
  클라이언트는 이 메서드를 호출한다.

1. **연결 서버**
  잠금을 수행하는 중간 단계를 생성한다.  
  ‘서버에서 잠금’ 방식과 유사하지만 원래 서버는 변경하지 않는다.

</details>

<details><summary>동기화하는 부분을 작게 만들어라</summary>   

락은 스레드를 지연시키고 부하를 가중시킨다.  
임계영역(critical section)은 반드시 보호해야 한다. 코드를 짤 때, 임계영역수를 최대한 줄이기!  

`Do NOT` → 임계영역 개수를 줄인답시고 거대한 임계영역 하나로 구현하면(필요 이상으로 임계 영역 크기를 키우면) 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.

</details>

<details><summary>올바른 종료 코드는 구현하기 어렵다</summary>  

- 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다.  
  - 흔히 발생하는 문제 : 데드락 → 스레드가 절대 오지 않을 시그널을 기다림.

- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현할것.  
  오래 걸리고 어려우므로 이미 나온 알고리즘을 검토하자.

</details>

<details><summary>스레드 코드 테스트하기</summary>  
<br>
비록 테스트를 통해 코드가 올바로 작성되었다고 보장할수는 없더라도 위험성을 낮추어 준다.  
- 문제를 노출하는 테스트 케이스를 작성할것.  
  테스트가 실패하면 원인 추적

- 프로그램 설정과 시스템 설정과 부하를 바꿔가며 돌리기.  
  다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다.

**지침 사항**
- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급할것.

- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들것.

- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현할것.

- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성할것.

- 프로세서 수보다 많은 스레드를 돌려볼것.

- 다른 플랫폼에서 돌려볼것.

- 강제로 실패를 일으키게 하기 위해 코드에 보조 코드를 넣어 돌려볼것.

</details>
<br>

# 17
## 냄새와 휴리스틱
> Smells and Heuristics

<details><summary>주석</summary>  

1. **(X) 부적절한 정보**  
   다른 시스템(`소스 코드 관리 시스템, 버그 추적 시스템 등`)에 저장할 정보  
      - 변경 이력   

1. **(X) 쓸모 없는 주석**
   쓸모 없는 주석은 코드를 그릇된 방향으로 이끌게 되니 주의!
      - 오래된 주석
      - 엉뚱한 주석
      - 잘못된 주석

1. **(X) 중복된 주석**  
   구구절절 설명하는 주석

1. **(X) 성의 없는 주석**  
   성의 없는 주석을 달지 않도록
      - 단어를 신중이 선택할 것
      - 올바른 문법과 구두점을 사용할 것

1. **(X) 주석 처리된 코드**  
   발견되는 즉시 지워버릴 것.  
   나중에 필요한 사람이 소스 코드 관리 시스템에서 해당 코드를 찾으면 된다.

</details>


<details><summary>환경</summary>

1. **(X) 여러 단계로 빌드**  
   명령어 하나로 빌드할 수 있도록 해야 한다.

1. **(X) 여러 단계로 테스트**  
   명령어 하나로 모든 단위테스트가 돌아가도록 해야 한다.

</details>


<details><summary>함수</summary>

1. **(X) 너무 많은 인수**  
   인수는 작으면 작을 수록 좋다. 아예 없는 것이 최고.

1. **(X) 출력 인수**  
   출력 인수가 존재함으로써 함수는 직관적이지 않게 된다. 출력 인수를 없애자.

1. **(X) 플래그 인수**  
   플래그 인수는 혼란을 초래, 플래그 인수를 피하자.

1. **(X) 죽은 함수**  
   호출되지 않는 함수(`죽은 코드`)는 삭제하자.

</details>


<details><summary>일반</summary>

1. **(X) 한 소스 파일에 여러 언어 사용**  
   한 소스 파일에 한가지 언어를 사용하는 것이 이상적.

1. **(X) 당연한 동작을 구현하지 않았을 경우**  
   당연한 동작을 구현해놓지 않으면 코드를 읽는 독자는 저자에 대한 신뢰가 무너진다.    
   결과적으로 독자는 다른 코드를 신임하지 못한채 일일이 살펴보게 된다.

1. **(X) 올바로 처리하지 않은 경계**  
   개발자의 머리속에서 코드를 돌려본후 끝내는 게으름을 피우지 말것.  
   실질적으로 잘 돌아가는지 확인하고, 모든 경계 조건을 테스트 해보라(`테스트 케이스 작성`).

1. **(X) 안전 절차 무시**  
   컴파일러 경고 일부를 무시하지 말자.   
   실패하는 테스트를 나중으로 미뤄두지 말자.

1. **(X) 중복**  
   DRY(`Don't Repeat Yourself`) 원칙을 기억하자.
   Once and Only Once 규칙을 따르자.
   중복된 코드를 발견했다면 추상화 할 타이밍이다.
      - 루틴으로 분리
      - 클래스로 분리
   switch/case & if/else 문은 다형성으로 대체할 것.
   유사한 알고리즘은 TEMPLATE METHOD 또는 STRATEGY 패턴을 사용할 것.

1. **(X) 올바르지 못한 추상화 수준**  
   추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리해야 한다.
   기초 클래스에서 제외할 것
      - 세부 구현과 관련된 상수
      - 세부 구현과 관련된 변수
      - 세부 구현과 관련된 유틸리티 함수

1. **(X) 파생 클래스에 의존하는 기초 클래스**  
   기억하자, 파생 클래스와 기초 클래스를 나누는 이유는 서로간의 독립성을 보장하기 위함이다.  
   이는 유지보수(`특정 컴포넌트 변경시 해당 변경이 시스템에 미치는 영향이 작아짐`)를 수월하게 진행할 수 있도록 해준다.

1. **(X) 과도한 정보**    
   잘 정의된 모듈 == 작은 인터페이스 == 낮은 결합도

   **숨겨여 할 것들**
      - 자료
      - 유틸리티 함수
      - 상수
      - 임시 변수

1. **(X) 죽은 코드**  
   죽은 코드 == 실행되지 않는 코드  
   죽은지 오래일 수록 악취는 강해진다, 장례(`시스템에서 제거`)를 치뤄주자.

1. **(O) 수직 분리**   
   옳바른 수직 분리란,
      - 변수/함수 : 사용되는 위치에 가깝게 정의
      - 지역변수 : 처음으로 사용하기 직전에 선언
      - 비공개 함수: 처음으로 호출되는 위치와 가깝게 위치시킬 것

1. **(X) 일관성 부족**  
   표기법은 신중하게 선택하고, 한번 선택한 표기법은 신중하게 유지하며 따르자.
  이로인해 코드를 일기 쉬워지며 수정하기도 수월해진다.

1. **(X) 잡동사니**  
  아래와 같은 잡동사니를 제거할 것
    - 비어 있는 기본 생성자
    - 아무도 사용하지 않는 변수
    - 아무도 호출하지 않는 함수
    - 정보를 제공하지 못하는 주석

1. **(X) 인위적 결합**  
   서로 무관한 개념은 인위적으로 결합하지 않는다.
      - 인위적인 결합 ⇒ 직접적인 상호작용이 없는 두 모듈의 결합
   **해결법**
    - 함수, 상수, 변수 선언시 올바른 위치가 어디인지 충분히 고민한 후 배치

1. **(X) 기능 욕심**  
   클래스 메서드는 자기 클래스의 변수/함수 외에 다른 클래스의 변수/함수를 조작해서는 안된다.  
   타 클래스의 기능을 욕심내어 범위를 침범하지 말자.

1. **(X) 선택자 인수**  
   선택자 인수는 목적을 기억하기 어렵게 만든다.  
   이는 게으름으로 부터 비롯되는 경우가 많다, true/false 의 인수를 전달하는 대신 함수를 여럿으로 쪼개자.

1. **(X) 모호한 의도**  
  모호한 의도를 가진 코드는 제거하자
     - 행을 바꾸지 않은 수식
     - 매직 번호

1. **(X) 잘못 지운 책임**  
   기능을 영리하게 배치할 줄 알아야 한다.
     - 개발자에게 편리한 함수에 배치 ⇒ 독자에게 직관 적인 위치로 배치

1. **(X) 부적절한 static 함수**  
   재정의할 가능성이 있는 함수는 static 함수로 정의하지 말것. 대신 인스턴스 함수를 사용하자.

1. **(O) 서술적 변수**  
   짧은 코드를 추구하기 보다는 이해를 돕기 위한 서술적인 코드(여러 단계로 나뉜)를 작성할 것

1. **(O) 이름과 기능이 일치하는 함수**  
   이름만으로 함수가 분명하지 않는다면 잘못 지은 이름이다.  
   함수가 구현한 기능과 이름이 일치하는지 확인하자.

1. **(O) 알고리즘을 이해하라**  
   괴상한 코드는 알고리즘을 충분히 이해하지 않은 상태에서 코드를 작성할때 비롯된다.  
   알고리즘 이해 없이 if 문 또는 플래그를 넣어 돌려보며 구현해 나가기 때문.
   알고리즘을 이해한 채 코드를 구현했다는 것.
      - 테스트 케이스를 모두 통과해야 함.
      - 작성자가 올바른 알고리즘이라는 것을 알아야 함.
      - 기능이 뻔히 보일 정도로 함수를 깔끔하게 작성해야 함.

1. **(O) 논리적 의존성은 물리적으로 드러내라**  
   한 모듈이 상대 모듈에 논리적으로 의존한다면 물리적인 의존성도 부여해야 한다.

1. **(O) If/Else 혹은 Switch/Case 문보다 다형성을 사용하라**  
   다형성 객체가 switch 문을 대신하게 하자.

1. **(O) 표준 기법을 따르라**  
   업계 표준 기법을 따르도록 하자. 팀이 정한 표준은 팀원들 모두가 따라야 한다.

1. **(O) 매직 숫자는 명명된 상수로 교체**  
   일반적으로 숫자는 명명된 상수를 사용하자.

1. **(O) 정확하라**  
   코드에서 무언가를 결정할 때는 대충 결정하지 말고 정확히 결정해야 한다.

   **정확한 결정을 내리는 법**  
    - 결정을 내리는 이유를 알 것.
    - 예외를 처리할 방법을 알 것.

   코드에서 모호성과 부정확성은 의견차이거나 게으름의 결과이다.

1. **(O) 관례보다 구조 사용**  
1. **(O) 조건을 캡슐화**  
   Good ⇒ `if (shouldBeDeleted(timer))`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `(timer.hasExpired() && !timer.isRecurrent())`

1. **(O) 부정 조건은 피하라**  
   부정 조건은 긍정 조건보다 이해하기 어렵기에 긍정 조건을 사용하도록 하자.  
   Good ⇒ `if (buffer.shouldCompact())`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `if (!buffer.shouldNotCompact())`  

1. **(O) 함수는 한 가지만**  
   여러 작업을 하는 함수라면 한 가지 기능만 담당하도록 여러개의 함수로 쪼갤 것.

1. **(X) 숨겨진 시간적인 결합**  
   함수가 호출되는 순서를 명백히 드러내도록 해야한다.

1. **(O) 일관성 유지**  
   구조에 일관성이 없다면 깨진 유리창 법칙처럼 남들도 비일관적인 코드를 작성하게 된다.

1. **(O) 경계 조건 캡슐화**  
   여러곳에서 경계 조건을 처리하지 말 것.  
   한 곳에서 별도로 처리하도록 하자.

1. **(O) 함수는 추상화 수준을 한 단계만 내려가야 한다**  
   함수의 추상화 수준은 이름이 의미하는 것보다 한 단계정도만 낮아야 한다.

1. **(O) 설정 정보는 최상위 단계에**  
   기본값 상수나 설정 관련 상수는 추상화 최상위 단계에 두어야 한다.

1. **(O) 추이적 탐색 피하기**  
   한 모듈이 주변 모듈을 알지 못하도록 만들어야 한다.
     - Law of Demeter ⇒ 자신이 직접 사용하는 모듈만 알아야 한다.  
        Bad ⇒ `a.getB().getC().doSomething();`

</details>


<details><summary>이름</summary>

1. **(O) 서술적인 이름 사용**  
   신중하게 서술적인 이름을 고를 것.  
   코드가 변했다면 이전에 지은 이름이 적합한지 확인할 것.

1. **(O) 적절한 추상화 수준에서 이름을 선택**  
   구현을 드러내는 이름을 사용하지 말것.

1. **(O) 가능하다면 표준 명명법을 사용**  

1. **(O) 명확한 이름**  
   명확한 이름 == 함수/변수의 목적이 명확히 드러나는 이름  
   Good ⇒ `renamePageAndOptionallyAllReferences`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `doRename`

1. **(O) 긴 범위는 긴 이름을 사용**  
   이름 길이는 범위의 길이에 비례해야 한다.  
      - 작은 범위 ⇒ 짧은 이름
      - 큰 범위 ⇒ 긴 이름

1. **(O) 인코딩 피하기**   
   이름에 유형 정보다 범위 정보를 넣지 말것.

1. **(O) 이름으로 부수 효과 설명**  
   함수/변수/클래스가 하는 일을 기술하는 이름을 사용하자.  
   Good ⇒ `getOos`  
  &nbsp;&nbsp;&nbsp;Bad ⇒ `createOrReturnOos`

</details>


<details><summary>테스트</summary>

1. **(X) 불충분한 테스트**  
   충분한 정도의 테스트란  
      - 깨질 만한 부분을 모두 테스트 한 정도

1. **(O) 커버리지 도구 사용**  
   커버리지 도구를 사용함으로써 테스트가 빠뜨리는 부분이 어디인지 쉽게 확인 가능하다.

1. **(O) 사소한 테스트를 건너뛰지 말것**  
   사소한 테스트는 짜기 쉽다는 이유로 건너뛰지 말자.

1. **(X) 무시한 테스트**  
   특정 부분을 테스트 하지 않고 무시한 채 지나갔다는 것은 모호한 부분이라는 것을 의미한다.  
   불분명한 요구사항을 분명하게 만들자.

1. **(O) 경계 조건을 테스트**  
   경계 조건은 각별히 신경써야 한다.

1. **(O) 버그 주변은 철저히 테스트**  
   버그는 모여 있는 경향이 있다.  
   한 함수에서 버그가 발생 하였다면 다른 버그는 없는지 철저히 테스트해보자.

1. **(O) 실패 패턴 살피기**  
   실패에도 패턴이 있을 수 있다. 이를 통해 문제를 진단하자.

1. **(O) 테스트 커버리지 패턴 살피기**  

1. **(O) 테스트는 빨라야 한다**  
   느린 테스트는 사용하지 않게 되므로 테스트 케이스들이 빠르게 돌아갈 수 있도록 작성하자.

</details>
