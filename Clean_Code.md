# Clean Code
Clean Code : A Handbook of Agile Software Craftmanship  
### Highfive Tech Book Club
하이파이브 기술 독서 모임 (매주 월요일 19:30 PM)

## Table of Contents

|Chapter|       Title      | Page  |   Date   |
|-------|:----------------:|:-----:|:--------:|
|01     |깨끗한 코드          |001-020|07.27.2020|
|02     |의미 있는 이름       |021-038|08.03.2020|
|03     |함수               |039-065|08.10.2020| 
|04     |주석               |067-094|08.24.2020|
|05     |형식 맞추기          |095-114|08.31.2020|
|06     |객체와 자료 구조      |117-128|09.07.2020| 
|07     |오류 처리           |129-142|09.14.2020|
|08     |경계               |143-152|09.21.2020|
|09     |단위 테스트          |153-170|09.28.2020| 
|10     |클래스             |171-192|10.05.2020|
|11     |시스템             |193-214|10.12.2020|
|12     |창발성             |215-224|10.19.2020| 
|13     |동시성             |225-244|10.26.2020|
|14     |점진적인 개선        |245-322|11.02.2020|
|15     |JUnite 들여다보기   |323-342|---Skip---| 
|16     |SerialDate 리팩터링 |343-365|---Skip---|
|[17](#17)|냄새와 휴리스틱      |367-406|11.09.2020|

# 17
## 냄새와 휴리스틱
<details><summary>주석</summary>  

1. **(X) 부적절한 정보**  
   다른 시스템(`소스 코드 관리 시스템, 버그 추적 시스템 등`)에 저장할 정보  
      - 변경 이력   

1. **(X) 쓸모 없는 주석**
   쓸모 없는 주석은 코드를 그릇된 방향으로 이끌게 되니 주의!
      - 오래된 주석
      - 엉뚱한 주석
      - 잘못된 주석

1. **(X) 중복된 주석**  
   구구절절 설명하는 주석

1. **(X) 성의 없는 주석**  
   성의 없는 주석을 달지 않도록
      - 단어를 신중이 선택할 것
      - 올바른 문법과 구두점을 사용할 것

1. **(X) 주석 처리된 코드**  
   발견되는 즉시 지워버릴 것.  
   나중에 필요한 사람이 소스 코드 관리 시스템에서 해당 코드를 찾으면 된다.

</details>


<details><summary>환경</summary>

1. **(X) 여러 단계로 빌드**  
   명령어 하나로 빌드할 수 있도록 해야 한다.

1. **(X) 여러 단계로 테스트**  
   명령어 하나로 모든 단위테스트가 돌아가도록 해야 한다.

</details>


<details><summary>함수</summary>

1. **(X) 너무 많은 인수**  
   인수는 작으면 작을 수록 좋다. 아예 없는 것이 최고.

1. **(X) 출력 인수**  
   출력 인수가 존재함으로써 함수는 직관적이지 않게 된다. 출력 인수를 없애자.

1. **(X) 플래그 인수**  
   플래그 인수는 혼란을 초래, 플래그 인수를 피하자.

1. **(X) 죽은 함수**  
   호출되지 않는 함수(`죽은 코드`)는 삭제하자.

</details>


<details><summary>일반</summary>

1. **(X) 한 소스 파일에 여러 언어 사용**  
   한 소스 파일에 한가지 언어를 사용하는 것이 이상적.

1. **(X) 당연한 동작을 구현하지 않았을 경우**  
   당연한 동작을 구현해놓지 않으면 코드를 읽는 독자는 저자에 대한 신뢰가 무너진다.    
   결과적으로 독자는 다른 코드를 신임하지 못한채 일일이 살펴보게 된다.

1. **(X) 올바로 처리하지 않은 경계**  
   개발자의 머리속에서 코드를 돌려본후 끝내는 게으름을 피우지 말것.  
   실질적으로 잘 돌아가는지 확인하고, 모든 경계 조건을 테스트 해보라(`테스트 케이스 작성`).

1. **(X) 안전 절차 무시**  
   컴파일러 경고 일부를 무시하지 말자.   
   실패하는 테스트를 나중으로 미뤄두지 말자.

1. **(X) 중복**  
   DRY(`Don't Repeat Yourself`) 원칙을 기억하자.
   Once and Only Once 규칙을 따르자.
   중복된 코드를 발견했다면 추상화 할 타이밍이다.
      - 루틴으로 분리
      - 클래스로 분리
   switch/case & if/else 문은 다형성으로 대체할 것.
   유사한 알고리즘은 TEMPLATE METHOD 또는 STRATEGY 패턴을 사용할 것.

1. **(X) 올바르지 못한 추상화 수준**  
   추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리해야 한다.
   기초 클래스에서 제외할 것
      - 세부 구현과 관련된 상수
      - 세부 구현과 관련된 변수
      - 세부 구현과 관련된 유틸리티 함수

1. **(X) 파생 클래스에 의존하는 기초 클래스**  
   기억하자, 파생 클래스와 기초 클래스를 나누는 이유는 서로간의 독립성을 보장하기 위함이다.  
   이는 유지보수(`특정 컴포넌트 변경시 해당 변경이 시스템에 미치는 영향이 작아짐`)를 수월하게 진행할 수 있도록 해준다.

1. **(X) 과도한 정보**    
   잘 정의된 모듈 == 작은 인터페이스 == 낮은 결합도

   **숨겨여 할 것들**
      - 자료
      - 유틸리티 함수
      - 상수
      - 임시 변수

1. **(X) 죽은 코드**  
   죽은 코드 == 실행되지 않는 코드  
   죽은지 오래일 수록 악취는 강해진다, 장례(`시스템에서 제거`)를 치뤄주자.

1. **(O) 수직 분리**   
   옳바른 수직 분리란,
      - 변수/함수 : 사용되는 위치에 가깝게 정의
      - 지역변수 : 처음으로 사용하기 직전에 선언
      - 비공개 함수: 처음으로 호출되는 위치와 가깝게 위치시킬 것

1. **(X) 일관성 부족**  
   표기법은 신중하게 선택하고, 한번 선택한 표기법은 신중하게 유지하며 따르자.
  이로인해 코드를 일기 쉬워지며 수정하기도 수월해진다.

1. **(X) 잡동사니**  
  아래와 같은 잡동사니를 제거할 것
    - 비어 있는 기본 생성자
    - 아무도 사용하지 않는 변수
    - 아무도 호출하지 않는 함수
    - 정보를 제공하지 못하는 주석

1. **(X) 인위적 결합**  
   서로 무관한 개념은 인위적으로 결합하지 않는다.
      - 인위적인 결합 ⇒ 직접적인 상호작용이 없는 두 모듈의 결합
   **해결법**
    - 함수, 상수, 변수 선언시 올바른 위치가 어디인지 충분히 고민한 후 배치

1. **(X) 기능 욕심**  
   클래스 메서드는 자기 클래스의 변수/함수 외에 다른 클래스의 변수/함수를 조작해서는 안된다.  
   타 클래스의 기능을 욕심내어 범위를 침범하지 말자.

1. **(X) 선택자 인수**  
   선택자 인수는 목적을 기억하기 어렵게 만든다.  
   이는 게으름으로 부터 비롯되는 경우가 많다, true/false 의 인수를 전달하는 대신 함수를 여럿으로 쪼개자.

1. **(X) 모호한 의도**  
  모호한 의도를 가진 코드는 제거하자
     - 행을 바꾸지 않은 수식
     - 매직 번호

1. **(X) 잘못 지운 책임**  
   기능을 영리하게 배치할 줄 알아야 한다.
     - 개발자에게 편리한 함수에 배치 ⇒ 독자에게 직관 적인 위치로 배치

1. **(X) 부적절한 static 함수**  
   재정의할 가능성이 있는 함수는 static 함수로 정의하지 말것. 대신 인스턴스 함수를 사용하자.

1. **(O) 서술적 변수**  
   짧은 코드를 추구하기 보다는 이해를 돕기 위한 서술적인 코드(여러 단계로 나뉜)를 작성할 것

1. **(O) 이름과 기능이 일치하는 함수**  
   이름만으로 함수가 분명하지 않는다면 잘못 지은 이름이다.  
   함수가 구현한 기능과 이름이 일치하는지 확인하자.

1. **(O) 알고리즘을 이해하라**  
   괴상한 코드는 알고리즘을 충분히 이해하지 않은 상태에서 코드를 작성할때 비롯된다.  
   알고리즘 이해 없이 if 문 또는 플래그를 넣어 돌려보며 구현해 나가기 때문.
   알고리즘을 이해한 채 코드를 구현했다는 것.
      - 테스트 케이스를 모두 통과해야 함.
      - 작성자가 올바른 알고리즘이라는 것을 알아야 함.
      - 기능이 뻔히 보일 정도로 함수를 깔끔하게 작성해야 함.

1. **(O) 논리적 의존성은 물리적으로 드러내라**  
   한 모듈이 상대 모듈에 논리적으로 의존한다면 물리적인 의존성도 부여해야 한다.

1. **(O) If/Else 혹은 Switch/Case 문보다 다형성을 사용하라**  
   다형성 객체가 switch 문을 대신하게 하자.

1. **(O) 표준 기법을 따르라**  
   업계 표준 기법을 따르도록 하자. 팀이 정한 표준은 팀원들 모두가 따라야 한다.

1. **(O) 매직 숫자는 명명된 상수로 교체**  
   일반적으로 숫자는 명명된 상수를 사용하자.

1. **(O) 정확하라**  
   코드에서 무언가를 결정할 때는 대충 결정하지 말고 정확히 결정해야 한다.

   **정확한 결정을 내리는 법**  
    - 결정을 내리는 이유를 알 것.
    - 예외를 처리할 방법을 알 것.

   코드에서 모호성과 부정확성은 의견차이거나 게으름의 결과이다.

1. **(O) 관례보다 구조 사용**  
1. **(O) 조건을 캡슐화**  
   Good ⇒ `if (shouldBeDeleted(timer))`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `(timer.hasExpired() && !timer.isRecurrent())`

1. **(O) 부정 조건은 피하라**  
   부정 조건은 긍정 조건보다 이해하기 어렵기에 긍정 조건을 사용하도록 하자.  
   Good ⇒ `if (buffer.shouldCompact())`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `if (!buffer.shouldNotCompact())`  

1. **(O) 함수는 한 가지만**  
   여러 작업을 하는 함수라면 한 가지 기능만 담당하도록 여러개의 함수로 쪼갤 것.

1. **(X) 숨겨진 시간적인 결합**  
   함수가 호출되는 순서를 명백히 드러내도록 해야한다.

1. **(O) 일관성 유지**  
   구조에 일관성이 없다면 깨진 유리창 법칙처럼 남들도 비일관적인 코드를 작성하게 된다.

1. **(O) 경계 조건 캡슐화**  
   여러곳에서 경계 조건을 처리하지 말 것.  
   한 곳에서 별도로 처리하도록 하자.

1. **(O) 함수는 추상화 수준을 한 단계만 내려가야 한다**  
   함수의 추상화 수준은 이름이 의미하는 것보다 한 단계정도만 낮아야 한다.

1. **(O) 설정 정보는 최상위 단계에**  
   기본값 상수나 설정 관련 상수는 추상화 최상위 단계에 두어야 한다.

1. **(O) 추이적 탐색 피하기**  
   한 모듈이 주변 모듈을 알지 못하도록 만들어야 한다.
     - Law of Demeter ⇒ 자신이 직접 사용하는 모듈만 알아야 한다.  
        Bad ⇒ `a.getB().getC().doSomething();`

</details>


<details><summary>이름</summary>

1. **(O) 서술적인 이름 사용**  
   신중하게 서술적인 이름을 고를 것.  
   코드가 변했다면 이전에 지은 이름이 적합한지 확인할 것.

1. **(O) 적절한 추상화 수준에서 이름을 선택**  
   구현을 드러내는 이름을 사용하지 말것.

1. **(O) 가능하다면 표준 명명법을 사용**  

1. **(O) 명확한 이름**  
   명확한 이름 == 함수/변수의 목적이 명확히 드러나는 이름  
   Good ⇒ `renamePageAndOptionallyAllReferences`  
   &nbsp;&nbsp;&nbsp;Bad ⇒ `doRename`

1. **(O) 긴 범위는 긴 이름을 사용**  
   이름 길이는 범위의 길이에 비례해야 한다.  
      - 작은 범위 ⇒ 짧은 이름
      - 큰 범위 ⇒ 긴 이름

1. **(O) 인코딩 피하기**   
   이름에 유형 정보다 범위 정보를 넣지 말것.

1. **(O) 이름으로 부수 효과 설명**  
   함수/변수/클래스가 하는 일을 기술하는 이름을 사용하자.  
   Good ⇒ `getOos`  
  &nbsp;&nbsp;&nbsp;Bad ⇒ `createOrReturnOos`

</details>


<details><summary>테스트</summary>

1. **(X) 불충분한 테스트**  
   충분한 정도의 테스트란  
      - 깨질 만한 부분을 모두 테스트 한 정도

1. **(O) 커버리지 도구 사용**  
   커버리지 도구를 사용함으로써 테스트가 빠뜨리는 부분이 어디인지 쉽게 확인 가능하다.

1. **(O) 사소한 테스트를 건너뛰지 말것**  
   사소한 테스트는 짜기 쉽다는 이유로 건너뛰지 말자.

1. **(X) 무시한 테스트**  
   특정 부분을 테스트 하지 않고 무시한 채 지나갔다는 것은 모호한 부분이라는 것을 의미한다.  
   불분명한 요구사항을 분명하게 만들자.

1. **(O) 경계 조건을 테스트**  
   경계 조건은 각별히 신경써야 한다.

1. **(O) 버그 주변은 철저히 테스트**  
   버그는 모여 있는 경향이 있다.  
   한 함수에서 버그가 발생 하였다면 다른 버그는 없는지 철저히 테스트해보자.

1. **(O) 실패 패턴 살피기**  
   실패에도 패턴이 있을 수 있다. 이를 통해 문제를 진단하자.

1. **(O) 테스트 커버리지 패턴 살피기**  

1. **(O) 테스트는 빨라야 한다**  
   느린 테스트는 사용하지 않게 되므로 테스트 케이스들이 빠르게 돌아갈 수 있도록 작성하자.

</details>
