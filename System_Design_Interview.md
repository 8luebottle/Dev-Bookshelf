# System Design Interview 
The objective of this book is to provide a reliable strategy to approach the system design questions.
The right strategy and knowledge are vital to the success of an interview. This book provides solid knowledge in building a scalable system.

### GIT X AWS Mentoring Program 
IT 기술 독서 with Amazon Web Services  
- System Design Interview 가상 면접 사례로 배우는 대규모 시스템 설계 기초

## Table of Contents

Chapter|         Title       | Page  |   Date
--------|:-------------------:|:-----:|:--------:
[01](#1)|사용자 수에 따른 규모 확장성|001-032|
02      |개략적인 규모 측정|033-038|
[03](#3)|시스템 설계 면접 공략법|039-050|
[04](#4)|처리율 제한 장치의 설계|051-076|
05      |안정 해시 설계|077-090|
06      |키-값 저장소 설계 |091-116|
07      |분산 시스템을 위한 유일 ID 생성기 설계|117-126|
08      |URL 단축기 설계|127-140|
09      |웹 크롤러 설계|141-164|
[10](#10)|알림 시스템 설계|165-182|
11      |뉴스 피드 시스템 설계|183-196|
12      |채팅 시스템 설계|197-222|
13      |검색어 자동완성 시스템|223-246|
14      |유튜브 설계|247-276|
15      |구글 드라이브 설계|277-300|
16      |배움은 계속된다|301-307|

---
# 1
## 사용자 수에 따른 규모 확장성
> Scale From Zero To Millions Of Users

시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다.

- **Stateless**  
  웹 계층은 무상태 계층으로
- **Redundancy**  
  모든 계층에 다중화 도입
- **Cache**  
  가능한 한 많은 데이터를 캐시할 것
- **Data centers**  
  여러 데이터 센터를 지원할 것
- **CDN**  
  정적 콘텐츠는 CDN을 통해 서비스할 것
- **Sharding**  
  데이터 계층은 샤딩을 통해 그 규모를  확장할 것
- **Split tiers**  
  각 계층은 독립적 서비스로 분할할 것
- **Monitor & Automation tool**  
  시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

<details><summary>NOTE</summary><br>

  사용자가 증가하게 되면 단일  서버로는 충분치 않아 여러 서버를 두게 된다.

<img width="546" alt="multiple servers" src="https://user-images.githubusercontent.com/48475824/130340899-9c14368b-57ca-49e0-a055-9cb133004ceb.png">

  - [서버 1: Web server] 웹/모바일 트래픽 처리용
  - [서버 2: Database] 데이터베이스 용

  보통의 경우 RDBMS를 사용하지만 비-관계형 DB가 필요시 되는 상황이 있다.

  NoSQL DB를 선택해야하는 경우는 아래와 같다.
  - **Super-low latency**  
    아주 낮은 응답 지연시간이 요구되는 경우
  - **Unstructured data**  
    비정형 데이터를 다뤄야하는 경우
  - **Only need to serialize & deserialize data**  
    데이터를 단순히 직렬화하거나 역직렬화만 하면 되는 경우
      - Data: JSON, YAML, XML, etc
  - **Massive amount of data**  
    상당히 대규모의 데이터를 저장해야 하는 경우

  ### Vertical scaling vs horizontal scaling
  DB의 규모를 확장 시 `수직적 확장`, `수평적 확장` 두 가지 방법이 있다
  - 서버로 유입되는 트래픽 양이 적을 경우 → `수직적 확장`
  - 대규모 앱을 지원할 경우 → `수평적 확장`

  ### Scale up 수직적 확장
  서버에 고사양 자원(CPU, RAM, etc)을 추가시키는 확장
  - **장점**
    - 단순함
  - **단점**
    - 비싼 비용
    - 규모 확장의 한계성
    - 장애에 대한 처리 미흡  
      예) failover, redundancy

  ### Scale out 수평적 확장
  더 많은 서버를 추가시키는 확장. 샤딩(sharding)이라고도 부름.
  - 대규모 DB를 작은 단위(shard)로 분할한다. 샤드에 보관되는 데이터 사이에는 중복 X.

  **[Sharding 도입 시 고려할 사항]**
  1. **Data resharding**   
    shard exhaustion 문제
  2. **Celebrity**   
    hotspot key 문제
  3. **Join and de-normalization**   
    여러 샤드에 걸친 데이터는 조인하기가 힘듬 ⇒ DB 비정규화를 통해 하나의 테이블에서 질의가 수행되도록 하기

  ## Load Balancer
  웹 서버들에게 트래픽을 고르게 분산시킴으로써 부하를 분산시켜준다.  
  - 웹 서버는 클라이언트의 접속을 직접 처리하지 X ⇒ 사용자들이 Load balancer의 Public IP 로 접속하기에
  - 보안성 향상 ⇒ 서버 간 통신에는 Private IP를 사용  
    Load balancer는 웹 서버와 통신시 private IP를 사용함.

  ## DB 다중화
  - 서버간에 first-second 관계를 설정
    - first: 데이터 원본, write operation
    - second: 데이터 사본, read operation
  - **장점**
    - 더 나은 성능
    - 안정성
    - 가용성

  ## Cache
  앱의 성능은 `DB를 얼마나 자주 호출하느냐`에 따라 좌우된다. 캐시를 통해 응답시간(latency)을 개선한다.
  - Cache tier
    - 응답 시간 개선
    - DB 부하 ↓

  **[Cache 사용시 고려 할 요소]**
  1. 어떤 상황에 캐시 사용?
  1. 어떤 데이터를 캐시에?
  1. 캐시에 보관된 데이터는 어떻게 만료?
  1. 일관성은 어떻게 유지?
  1. 장애는 어떻게 대처?
    예) SPOF 피하기
  1. 캐시 메모리의 크기는?
  1. 데이터 방출(eviction) 정책은?
    예) LRU, LFU, FIFO, etc

  ## CDN
  정적 콘텐츠를 전송시 CDN(콘텐츠 전송 네트워크)을 이용한다.
  **[CDN 사용시 고려할 요소]**
  1. 비용
  1. 적절한 만료 시한 설정
    - 너무 짧을 경우 ⇒ 원본 서버에 빈번히 접속하게 됨
    - 너무 길 경우 ⇒ 콘텐츠의 신선도가 떨어지게 됨
  1. 장애에 대한 대처 방안
  1. 콘텐츠 무효화(invalidation) 방법

  ## Stateless
  웹 계층을 수평적으로 확장하기 위해서는 상태정보를 웹 계층에서 제거해 주어야 한다. (무상태 웹 계층)
  - 상태 정보의 예) user's session data
  상태 정보가 웹 서버로부터 물리적으로 분리됨으로써 구조는 단순해지고, 안정적이며, 규모 확장이 쉬워지게 된다.

  ## Data centers
  여러 데이터 센터를 사용함으로써 전 세계 유저가 원하는 콘텐츠를 빠르게 이용 가능하도록 한다.
  - geo-routing: 사용자에게 가장 가까운 데이터 센터로 안내

  **[다중 데이터 센터 아키텍처의 기술적 난제]**
  1. 트래픽 우회
  1. 데이터 동기화
  1. 테스트와 배포

  ## Message Queue
  시스템의 component를 분리하기 위해 메시지 큐를 사용한다. 느슨한 결합으로 인해 독립적인 확장이 가능해진다.
  - 메시지의 버퍼 역할을 한다.
  - 비동기적으로 전송한다.

  ## Log, Metric, and Automation
  - **Log**   
    시스템의 오류와 문제들을 쉽게 찾아낼 수 있게 해주기 위해 에러 로그를 모니터링 할 것.
  - **Metric**  
    수집한 매트릭을 통해 사업 현황에 관한 주요 정보를 얻을 수 있다. 또한 시스템의 현재 상태를 파악할 수 있다.
    - Host level metrics  
      CPU, Memory, Disk I/O, etc
    - Aggregated level metrics  
      database tier, cache tier, etc
    - Key business metrics  
      daily active users, retention, revenue, etc
    - Automation

</details>

# 3
## 시스템 설계 면접 공략법
> A Framework For System Design Interviews

시스템 설계 면접: 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내가는 과정을 시뮬레이션 하는 것.

**Key points**
- 설계 기술 능력
- 설계 과정에서 내린 결정들에 대한 방어 능력
- 받은 피드백을 건설적인 방식으로 해결할 수 있는 능력

**주의** 
- Over-engineering
  - 과도한 엔지니어링으로 시스템 전반의 비용이 올라가는 것을 주의 할 것.
    - 타협한 만한 것은 타협하자.
- 완고함
- 편협함

<details><summary>NOTE</summary><br>

## 효과적 면접을 위한 4단계 접근법

### 1st Step 문제 이해 및 설계 범위 확정
#### Don't  
  1. 답을 성급히 내놓기 → 잘못된 시스템을 설계할 가능성이 높아짐.

#### Do  
  1. 요구사항과 가정들을 분명히 할 것.  
    예) 구체적으로 만들어야 하는 기능은?
  1. 올바른 질문을 할 것.  
    예) 가장 중요한 기능은? 데이터는 시간 역순으로 정렬되야 하는가?
  1. 적절한 가정을 할 것.
  1. 시스템 구축에 필요한 정보를 모을 것.  
    예) 제품의 사용자 수는? 회사의 규모는 얼마나 빨리 커질 것인가?

### 2nd Step 개략적인 설계안 제시 및 동의 구하기
개략적인 설계안을 제시하며 면접과 협력하며 진행.
- 면접관을 팀원인것 처럼 대하며 진행한다.

#### Do
1. 설계안에 대한 청사진을 제공 및 의견 구하기.
1. 다이어그램 그리기.  
  예) API, 웹 서버, 데이터 저장소, 캐시, CDN, etc.
1. 설계안이 요구된 제약사항들을 만족하는지 확인하기.

### 3rd Step 상세 설계
상세 설계 단계에서는 앞서 만든 청사진을 기준으로 설계 대상 컴포넌트 사이의 우선순위를 정하는 것이다.  
- 면접관은 시스템의 컴포넌트들의 세부사항을 깊이 있게 설명하는 것을 보기 원한다.

### 4th Step 마무리
면접관의 `후속 질문에 대한 답변하기` 또는 `개선 가능한 지점이 무엇이 있는지` 답하기.

1. 자신이 만든 설계 요약하기.
1. 오류 발생시 무슨 일이 생기는지 설명하기.
1. 운영 이슈는 어떻게 다룰 것인지 설명하기.
1. 규모 확장이 요구 될 때 어떻게 대처해 나갈 것인지 설명하기.
1. 세부 개선 사항 제안하기.

#### Don't
1. 요구 사항이나 가정이 불분명한 상태에서 설계를 제시하기.
1. 초기에 특정 컴포넌트으 세부 사항을 너무 깊이있게 설명하기.
1. 막힌 부분에서 면접관에게 힌트를 요청하지 않기.
1. 소통 없이 침묵 속에 설계 진행하기.

#### Do
1. 의견을 일찍 그리고 자주 구할 것.
1. 질문을 통해 확인 할 것.
1. 문제의 요구사항을 이해할 것.
1. 정답 또는 최선의 답안은 존재하지 않는 다는 것을 알 것.
1. 면접관이 자신의 사고 흐름을 알 수 있도록 할 것.
1. 가능하다면 여러 해법을 제시할 것.
1. 세부사항 설명시 가장 중요한 컴포넌트부터 진행할 것.

</details>

# 4
## 처리율 제한 장치의 설계
> Design A Rate Limiter

처리율 제한 장치: 트래픽의 처리율(rate)을 제어하기 위한 장치
- 예) 같은 디바이스로 주당 5회 이상의 reward 요청 금지 

처리율 제한 장치를 어디에 둘 것인가?  

어느 처리율 제한 알고리즘을 사용 할 것인가?

### 처리율 제한 알고리즘
여러가지 처리율 제한 알고리즘이 존재한다.

1. Token Bucket  
  토큰 버킷
1. Leaky Bucket  
  누출 버킷
1. Fixed Window Counter  
  고정 윈도우 카운터
1. Sliding Window Log  
  이동 윈도우 로그
1. Sliding Window Counter  
  이동 윈도우 카운터

<details><summary>NOTE</summary><br>

### 1st Step 문제 이해 및 설계 범위 확정
처리율 제한 알고리즘은 각각의 장단점을 지니고 있다. 면접관과 소통을 통해 구현해야 하는 제한 장치에 알맞는 알고리즘을 적용하도록 하자.  

**질문의 예)**  
- 클라이언트 측 제한 장치인지, 서버 측 제한 장치인지?
- 시스템이 분산 환경에서 동작해야 하는지?

질문에 대한 답변을 토대로 시스템 요구사항을 요약한다.

### 2nd Step 개략적 설계안 제시 및 동의 구하기

마이크로 서비스의 경우 보통 API Gateway 쪽에 처리율 제한장치를 위치시킨다.

**[처리율 제한 장치의 위치]**
> Client-Server 통신 모델의 경우  

해당 장치를 클라이언트, 서버 또는 미들웨어에 둘 수 있다.  
처리율 제한 장치의 위치 선정은 엔지니어 수, 회사의 기술 스택, 우선수위, 그리고 목표에 좌우된다.

- **Client**  
  처리율 제한이 안정적으로 동작 못할 가능성이 높음.  
  - 원인: 클라이언트 요청은 쉽게 위변조가 가능하기 때문.

  뿐만아니라 모든 클라이언트 구현을 통제하는 것도 어려움.

- **Sever**  
  서버측에 구현시 처리율 제한 알고리즘의 선택의 제한이 없다.

  <img width="700" alt="Rate Limiter-SS" src="https://user-images.githubusercontent.com/48475824/131516491-4feec0ff-b959-4b6e-9656-091976cda67d.png">  


- **Middleware**  
  제 3 사업자가 제공하는 서비스(API Gateway 와 같은)를 선택했을 시, 선택가능한 알고리즘은 제한적이다.

  <img width="730" alt="Rate Limiter-MW" src="https://user-images.githubusercontent.com/48475824/131517254-426dc235-224a-4c20-a703-f9512ba5ca65.png">

  미들웨어로 API 서버로 가는 요청을 통제한다.  


위치 선정 시 점검 사항
- 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기에 효율이 좋은가?
- 처리율 제한 장치를 직접 구현하는데 충분한 인력이 있는가?


### 3rd Step 상세 설계

상세 설계시 생각해 보아야 할 것  
- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리되는가?

처리율 제한 장치가 사용하는 HTTP Header
- `X-Ratelimit-Remaining`
- `X-Ratelimit-Limit`
- `X-Ratelimit-Retry-After`

**[분산 환경에서의 처리율 제한 장치의 구현]**  
분산 환경에서 대두되는 문제는 크게 두가지가 있다.  
1. Race condition 경쟁 조건
1. Synchronization 동기화  

**[모니터링]**  
처리율 제한 장치가 잘 동작하는지 데이터를 통해 모니터링 해야 한다.  
- 채택한 알고리즘이 효과적인가?
- 정의한 처리율 제한 규칙이 효과적인가?

### 4th Step 마무리
- Hard and Soft 처리율 제한
  - Hard 처리율 제한: 요청의 개수는 임계치를 절대 넘을 수 없음.
  - Soft 처리율 제한: 요청의 개수는 임계치를 잠시 동안 넘을 수 있음.
- 다양한 계층에서의 처리율 제한
- 처리율 제한을 피하기 위해 클라이언트를 어떻게 설계할 것인가?
  - 클라이언트 측 캐시를 통해 API 호출 횟수를 줄일 것.
  - 처리율 제한의 임계치를 잘 이해하고, 짧은 시간 동안 너무 많은 메시지를 보내지 않도록 할 것.
  - 예외 및 에러 처리를 통해 예외적인 상황에서도 잘 복구 될 수 있도록 할 것.
  - Retry 로직 구현시 충분한 Back-off 시간을 둘 것.

</details>


# 10
## 알림 시스템 설계
> Design A Notification System

알림 기능을 통해 중요한 정보를 비동기적으로 제공한다.  

**[알림 시스템]**  
- 모바일 푸시 알림
- SMS 메시지
- 이메일

<details><summary>NOTE</summary><br>

### 1st Step 문제 이해 및 설계 범위 확정
확장성 높은 알람 시스템을 설계하는 것은 쉽지 않다. 알림 시스템이 어떻게 구현되는지 깊은 이해가 필요하다.  
해당 시스템 관련 문제는 보통 모호하게 주어진다. 좋은 질문을 통해 요구사항을 구체화 시키자.

**질문의 예)**
- 어떤 종류의 알림을 지원해야 하는가?
- 실시간 시스템이어야 하는가?
- 어떤 종류의 단말을 지원해야 하는가?  
  - iOS, Android, Laptop, Desktop, etc
- 사용자가 알림 받지 않기를 설정 가능한가?
  - opt-out
- 하루의 몇 건의 알림을 보낼 수 있어야 하는가?

### 2nd Step 개략적 설계안 제시 및 동의 구하기

- DB와 Cache를 알림 시스템의 기존 하나의 주 서버에서 분리할 것.
- 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어 질 수 있도록 할 것.
- 메시지 큐를 통해 시스템 컴포넌트 사이의 강한 결합을 끊을 것.

알림 서버는 다음과 같은 기능을 제공하도록 한다.
- 알림 전송 API  
  스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 이용 가능.

- 알림 검증  
  이메일 주소, 전화번호 등을 검증.

- DB 또는 Cache 질의  
  알림에 포함시킬 데이터를 가져오는 기능.

- 알림 전송  
  알림 데이터를 메시지 큐에 넣어 전송.  
  여러개의 큐를 사용함으로 병렬 처리.

### 3rd Step 상세 설계
상세 설계시에는 아래와 같은 것들에 집중한다.  
- 안정성(reliability)

- 추가 컴포넌트 및 고려사항  
  알림 템플릿, 알림 설정, 전송률 제한, retry mechanism, 보안, 큐에 보관된 알림에 대한 모니터링과 이벤트 추적

**[안정성]**  
1. 데이터 손실 방지  
  어떠한 상황에서도 알림이 소실되면 안된다.
    - 이를 만족하기 위해 알림 시스템이 데이터를 DB에 보관하고 재시도 매커니즘을 수행할 수 있도록 해야한다.
1. 알림 중복 전송 방지  
  알림이 중복되어 전송하지 않도록 완전히 방지하는 것은 불가능 하다.  
  중복 전송의 빈도를 줄이기 위해 중복 탐지 매커니즘을 도입해야하며 오류를 신중하게 처리해야 한다.  
  예)  
    ⇒ 보내야 할 알림 도착시 해당 이벤트 ID를 검사  
    ⇒ 중복된 이벤트 일 시 버림  
    ⇒ 그렇지 않을 시 알림 발송

**[추가로 필요한 컴포넌트 및 고려사항]**  

- 알림 템플릿

- 알림 설정  
  사용자가 알림 설정을 상세히 조정할 수 있도록 한다.

- 전송률 제한  
  사용자가 너무 많은 알림을 받을 시 피로함을 느껴 알림을 끄게 됨으로 사용자당 전송하는 알림의 빈도를 제한해야 한다.

- 재시도 방법  
  전송 실패시 재시도 전용 큐에 담는다.  
  만약 지속적 문제 발생시 개발자에게 알림이 가도록 한다.

- 푸시 알림과 보안  

- 큐 모니터링  
  알림 시스템을 모니터링 시 중요한 metric 중 하나는 큐에 쌓인 알림의 개수.  
  개수가 많음: 작업 서버들이 이벤트를 빠르게 처리하지 못한다는 반증 ⇒  작업 서버 증설할 것.

- 이벤트 추적

### 4th Step 마무리 
알림은 필요불가결한 기능이다. 중점을 두어야 하는 것들은 아래와 같다.  

- Reliability  
  안정적인 재시도 매커니즘

- Security  
  인증된 클라이언트만이 알림을 보낼 수 있도록 할 것.

- 이벤트 추적 및 모니터링  
  알림이 만들어진 후 성공적으로 전송되기까지의 과정을 추적할 것.

- 사용자 설정  
  사용자가 알림 수신 설정을 조정할 수 있도록 할 것.

- 전송률 제한  
  알림을 보내는 빈도를 제한할 수 있도록 할 것.

</details>
